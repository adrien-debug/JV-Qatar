"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/mockData.ts":
/*!*****************************!*\
  !*** ./src/lib/mockData.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generate24HourConsumption: function() { return /* binding */ generate24HourConsumption; },\n/* harmony export */   generate24HourHashrate: function() { return /* binding */ generate24HourHashrate; },\n/* harmony export */   generate24HourRevenue: function() { return /* binding */ generate24HourRevenue; },\n/* harmony export */   generateBlockPowerDistribution: function() { return /* binding */ generateBlockPowerDistribution; },\n/* harmony export */   generateTemperatureData: function() { return /* binding */ generateTemperatureData; },\n/* harmony export */   generateVoltageCurrentData: function() { return /* binding */ generateVoltageCurrentData; },\n/* harmony export */   getCurrentElectricityMetrics: function() { return /* binding */ getCurrentElectricityMetrics; },\n/* harmony export */   getCurrentMiningMetrics: function() { return /* binding */ getCurrentMiningMetrics; }\n/* harmony export */ });\n/**\n * Mock data generators for dashboard tracking\n * Simulates realistic data for electricity and Bitcoin mining tracking\n */ // Electricity tracking data\nfunction generate24HourConsumption() {\n    const data = [];\n    const basePower = 102.4 // MW\n    ;\n    const hours = 24;\n    const now = new Date();\n    const currentHour = now.getHours();\n    for(let i = 0; i < hours; i++){\n        // Pattern quotidien réaliste : plus bas la nuit (2-6h), pic en journée (10-16h)\n        const hourOfDay = (currentHour + i) % 24;\n        let dailyPattern = 1.0;\n        if (hourOfDay >= 2 && hourOfDay <= 6) {\n            // Nuit : consommation réduite (85-95%)\n            dailyPattern = 0.85 + (hourOfDay - 2) * 0.025;\n        } else if (hourOfDay >= 10 && hourOfDay <= 16) {\n            // Journée : pic de consommation (100-105%)\n            dailyPattern = 1.0 + (hourOfDay - 10) * 0.008;\n        } else if (hourOfDay >= 18 && hourOfDay <= 22) {\n            // Soirée : consommation modérée (95-100%)\n            dailyPattern = 0.95 + (hourOfDay - 18) * 0.0125;\n        } else {\n            // Transition : consommation moyenne (90-100%)\n            dailyPattern = 0.9 + Math.abs(hourOfDay - 12) * 0.008;\n        }\n        // Variation aléatoire avec tendance lisse\n        const randomVariation = 0.97 + Math.random() * 0.06;\n        // Ajout d'une petite oscillation pour rendre la courbe plus naturelle\n        const smoothWave = Math.sin(i / 24 * Math.PI * 4) * 0.02;\n        const value = basePower * dailyPattern * randomVariation + smoothWave * basePower;\n        data.push({\n            hour: i,\n            value: Math.round(value * 10) / 10\n        });\n    }\n    return data;\n}\nfunction generateBlockPowerDistribution() {\n    const blocks = [\n        {\n            id: \"block-1\",\n            name: \"Block 1\"\n        },\n        {\n            id: \"block-2\",\n            name: \"Block 2\"\n        },\n        {\n            id: \"block-3\",\n            name: \"Block 3\"\n        },\n        {\n            id: \"block-4\",\n            name: \"Block 4\"\n        }\n    ];\n    // Valeurs mockup réalistes et équilibrées pour chaque bloc\n    const baseValues = [\n        25.8,\n        25.4,\n        25.6,\n        25.2\n    ] // Légèrement différentes pour montrer la variation\n    ;\n    return blocks.map((block, index)=>({\n            blockId: block.id,\n            blockName: block.name,\n            value: baseValues[index] + (Math.random() * 0.4 - 0.2 // Petite variation autour de la valeur de base\n            )\n        }));\n}\nfunction generateVoltageCurrentData() {\n    const data = [];\n    const baseVoltage = 33 // kV\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        // Tension avec variation réaliste : légère baisse en journée (charge réseau)\n        const hourOfDay = i;\n        let voltageVariation = 0;\n        if (hourOfDay >= 8 && hourOfDay <= 18) {\n            // Journée : légère baisse due à la charge réseau (-0.15 à -0.05 kV)\n            voltageVariation = -0.15 + (hourOfDay - 8) * 0.01;\n        } else {\n            // Nuit : tension plus stable, légèrement plus élevée\n            voltageVariation = 0.05 - Math.abs(hourOfDay - 12) * 0.003;\n        }\n        // Variation aléatoire fine\n        const randomNoise = Math.random() * 0.15 - 0.075;\n        // Oscillation très légère pour courbe naturelle\n        const microWave = Math.sin(i / 24 * Math.PI * 6) * 0.03;\n        const voltage = baseVoltage + voltageVariation + randomNoise + microWave;\n        data.push({\n            hour: i,\n            value: Math.round(voltage * 10) / 10\n        });\n    }\n    return data;\n}\nfunction getCurrentElectricityMetrics() {\n    const now = new Date();\n    const currentHour = now.getHours();\n    // Pattern réaliste selon l'heure\n    let powerMultiplier = 1.0;\n    if (currentHour >= 2 && currentHour <= 6) {\n        powerMultiplier = 0.88 + (currentHour - 2) * 0.03;\n    } else if (currentHour >= 10 && currentHour <= 16) {\n        powerMultiplier = 1.0 + (currentHour - 10) * 0.006;\n    } else if (currentHour >= 18 && currentHour <= 22) {\n        powerMultiplier = 0.96 + (currentHour - 18) * 0.01;\n    } else {\n        powerMultiplier = 0.92 + Math.abs(currentHour - 12) * 0.006;\n    }\n    const basePower = 102.4;\n    const currentPower = basePower * powerMultiplier + (Math.random() * 1.5 - 0.75);\n    // Tension corrélée avec la charge\n    const voltageVariation = currentHour >= 8 && currentHour <= 18 ? -0.12 : 0.05;\n    const voltage = 33 + voltageVariation + (Math.random() * 0.2 - 0.1);\n    const current = Math.round(currentPower * 1000000 / (1.732 * 33000));\n    const efficiency = 93 + Math.random() * 4.5 // 93-97.5%\n    ;\n    const costPerHour = currentPower * 0.052 // Coût légèrement variable\n    ;\n    return {\n        totalPowerMW: Math.round(currentPower * 10) / 10,\n        voltageKV: Math.round(voltage * 10) / 10,\n        currentA: current,\n        efficiencyPercent: Math.round(efficiency * 10) / 10,\n        costPerHourUSD: Math.round(costPerHour * 100) / 100\n    };\n}\n// Bitcoin mining tracking data\nfunction generate24HourHashrate() {\n    const data = [];\n    const baseHashrate = 500 // TH/s (estimated for 64 containers at ~7.8 TH/s each)\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        // Hashrate avec variations réalistes : légère baisse en journée (température)\n        const hourOfDay = i;\n        let efficiencyFactor = 1.0;\n        // Légère variation selon l'heure (température ambiante affecte légèrement)\n        if (hourOfDay >= 12 && hourOfDay <= 18) {\n            // Après-midi : légère baisse due à température (98-99%)\n            efficiencyFactor = 0.98 + (hourOfDay - 12) * 0.0017;\n        } else if (hourOfDay >= 2 && hourOfDay <= 6) {\n            // Nuit : performance optimale (100-101%)\n            efficiencyFactor = 1.0 + (hourOfDay - 2) * 0.0025;\n        } else {\n            // Autres heures : performance normale (99-100%)\n            efficiencyFactor = 0.99 + Math.abs(hourOfDay - 12) * 0.0008;\n        }\n        // Variation aléatoire fine\n        const randomVariation = 0.985 + Math.random() * 0.03;\n        // Petite oscillation pour courbe naturelle\n        const smoothWave = Math.cos(i / 24 * Math.PI * 3) * 0.015;\n        const value = baseHashrate * efficiencyFactor * randomVariation + smoothWave * baseHashrate;\n        data.push({\n            hour: i,\n            value: Math.round(value * 10) / 10\n        });\n    }\n    return data;\n}\nfunction generate24HourRevenue() {\n    const data = [];\n    const baseRevenue = 0.5 // BTC per day (estimated)\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        // Revenus avec pattern réaliste : corrélé avec hashrate\n        const hourOfDay = i;\n        // Pattern similaire au hashrate (performance affecte les revenus)\n        let revenueFactor = 1.0;\n        if (hourOfDay >= 12 && hourOfDay <= 18) {\n            revenueFactor = 0.97 + (hourOfDay - 12) * 0.002;\n        } else if (hourOfDay >= 2 && hourOfDay <= 6) {\n            revenueFactor = 1.0 + (hourOfDay - 2) * 0.003;\n        } else {\n            revenueFactor = 0.98 + Math.abs(hourOfDay - 12) * 0.001;\n        }\n        // Variation aléatoire plus importante (marché Bitcoin volatile)\n        const marketVolatility = 0.92 + Math.random() * 0.16;\n        // Oscillation pour simuler la volatilité du marché\n        const marketWave = Math.sin(i / 24 * Math.PI * 5) * 0.04;\n        const hourlyRevenue = baseRevenue / 24 * revenueFactor * marketVolatility;\n        const value = hourlyRevenue + marketWave * (baseRevenue / 24);\n        data.push({\n            hour: i,\n            value: Math.max(0, Math.round(value * 1000000) / 1000000)\n        });\n    }\n    return data;\n}\nfunction generateTemperatureData() {\n    const data = [];\n    const baseTemp = 25 // Celsius (cooled by hydro)\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        const hourOfDay = i;\n        // Pattern de température réaliste : plus froid la nuit, plus chaud en journée\n        let ambientTemp = baseTemp;\n        if (hourOfDay >= 2 && hourOfDay <= 6) {\n            // Nuit : température plus basse (20-23°C)\n            ambientTemp = 20 + (hourOfDay - 2) * 0.75;\n        } else if (hourOfDay >= 12 && hourOfDay <= 16) {\n            // Après-midi : température plus élevée (27-30°C)\n            ambientTemp = 27 + (hourOfDay - 12) * 0.75;\n        } else if (hourOfDay >= 8 && hourOfDay <= 11) {\n            // Matin : montée progressive (23-27°C)\n            ambientTemp = 23 + (hourOfDay - 8) * 1.33;\n        } else if (hourOfDay >= 17 && hourOfDay <= 21) {\n            // Soir : descente progressive (30-24°C)\n            ambientTemp = 30 - (hourOfDay - 17) * 1.5;\n        } else {\n            // Transition : interpolation\n            ambientTemp = 24 + Math.sin(hourOfDay / 24 * Math.PI * 2) * 4;\n        }\n        // Variation aléatoire fine\n        const randomVariation = Math.random() * 1.5 - 0.75;\n        // Oscillation très légère\n        const microWave = Math.cos(i / 24 * Math.PI * 4) * 0.5;\n        const value = ambientTemp + randomVariation + microWave;\n        data.push({\n            hour: i,\n            value: Math.round(value * 10) / 10\n        });\n    }\n    return data;\n}\nfunction getCurrentMiningMetrics() {\n    const hashrate = 500 + (Math.random() * 20 - 10 // TH/s\n    );\n    const activeContainers = 64 - Math.floor(Math.random() * 2) // 63-64 active\n    ;\n    const avgTemperature = 25 + (Math.random() * 5 - 2.5 // 22.5-27.5°C\n    );\n    const efficiency = 25 + Math.random() * 2 // J/TH (joules per terahash)\n    ;\n    const dailyRevenueBTC = 0.5 + (Math.random() * 0.1 - 0.05);\n    const btcPrice = 45000 // USD (example)\n    ;\n    const dailyRevenueUSD = dailyRevenueBTC * btcPrice;\n    return {\n        hashrateTHs: Math.round(hashrate * 10) / 10,\n        activeContainers,\n        avgTemperature: Math.round(avgTemperature * 10) / 10,\n        efficiencyJTH: Math.round(efficiency * 10) / 10,\n        dailyRevenueBTC: Math.round(dailyRevenueBTC * 1000000) / 1000000,\n        dailyRevenueUSD: Math.round(dailyRevenueUSD)\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBT3JELENBQUFBLEtBQUtHLE1BQU0sS0FBSyxLQUFLLEdBQUksT0FBTztJQUFWO0lBQzlDLE1BQU1tRCxtQkFBbUIsS0FBS3RELEtBQUt1RCxLQUFLLENBQUN2RCxLQUFLRyxNQUFNLEtBQUssR0FBRyxlQUFlOztJQUMzRSxNQUFNcUQsaUJBQWlCLEtBQU14RCxDQUFBQSxLQUFLRyxNQUFNLEtBQUssSUFBSSxJQUFLLGNBQWM7SUFBakI7SUFDbkQsTUFBTTRCLGFBQWEsS0FBTS9CLEtBQUtHLE1BQU0sS0FBSyxFQUFHLDZCQUE2Qjs7SUFDekUsTUFBTXNELGtCQUFrQixNQUFPekQsQ0FBQUEsS0FBS0csTUFBTSxLQUFLLE1BQU0sSUFBRztJQUN4RCxNQUFNdUQsV0FBVyxNQUFNLGdCQUFnQjs7SUFDdkMsTUFBTUMsa0JBQWtCRixrQkFBa0JDO0lBRTFDLE9BQU87UUFDTEUsYUFBYTVELEtBQUtVLEtBQUssQ0FBQzJDLFdBQVcsTUFBTTtRQUN6Q0M7UUFDQUUsZ0JBQWdCeEQsS0FBS1UsS0FBSyxDQUFDOEMsaUJBQWlCLE1BQU07UUFDbERLLGVBQWU3RCxLQUFLVSxLQUFLLENBQUNxQixhQUFhLE1BQU07UUFDN0MwQixpQkFBaUJ6RCxLQUFLVSxLQUFLLENBQUMrQyxrQkFBa0IsV0FBVztRQUN6REUsaUJBQWlCM0QsS0FBS1UsS0FBSyxDQUFDaUQ7SUFDOUI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL21vY2tEYXRhLnRzP2ZmZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2NrIGRhdGEgZ2VuZXJhdG9ycyBmb3IgZGFzaGJvYXJkIHRyYWNraW5nXG4gKiBTaW11bGF0ZXMgcmVhbGlzdGljIGRhdGEgZm9yIGVsZWN0cmljaXR5IGFuZCBCaXRjb2luIG1pbmluZyB0cmFja2luZ1xuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgSG91cmx5RGF0YVBvaW50IHtcbiAgaG91cjogbnVtYmVyXG4gIHZhbHVlOiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCbG9ja0RhdGFQb2ludCB7XG4gIGJsb2NrSWQ6IHN0cmluZ1xuICBibG9ja05hbWU6IHN0cmluZ1xuICB2YWx1ZTogbnVtYmVyXG59XG5cbi8vIEVsZWN0cmljaXR5IHRyYWNraW5nIGRhdGFcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZTI0SG91ckNvbnN1bXB0aW9uKCk6IEhvdXJseURhdGFQb2ludFtdIHtcbiAgY29uc3QgZGF0YTogSG91cmx5RGF0YVBvaW50W10gPSBbXVxuICBjb25zdCBiYXNlUG93ZXIgPSAxMDIuNCAvLyBNV1xuICBjb25zdCBob3VycyA9IDI0XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcbiAgY29uc3QgY3VycmVudEhvdXIgPSBub3cuZ2V0SG91cnMoKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG91cnM7IGkrKykge1xuICAgIC8vIFBhdHRlcm4gcXVvdGlkaWVuIHLDqWFsaXN0ZSA6IHBsdXMgYmFzIGxhIG51aXQgKDItNmgpLCBwaWMgZW4gam91cm7DqWUgKDEwLTE2aClcbiAgICBjb25zdCBob3VyT2ZEYXkgPSAoY3VycmVudEhvdXIgKyBpKSAlIDI0XG4gICAgbGV0IGRhaWx5UGF0dGVybiA9IDEuMFxuICAgIFxuICAgIGlmIChob3VyT2ZEYXkgPj0gMiAmJiBob3VyT2ZEYXkgPD0gNikge1xuICAgICAgLy8gTnVpdCA6IGNvbnNvbW1hdGlvbiByw6lkdWl0ZSAoODUtOTUlKVxuICAgICAgZGFpbHlQYXR0ZXJuID0gMC44NSArIChob3VyT2ZEYXkgLSAyKSAqIDAuMDI1XG4gICAgfSBlbHNlIGlmIChob3VyT2ZEYXkgPj0gMTAgJiYgaG91ck9mRGF5IDw9IDE2KSB7XG4gICAgICAvLyBKb3VybsOpZSA6IHBpYyBkZSBjb25zb21tYXRpb24gKDEwMC0xMDUlKVxuICAgICAgZGFpbHlQYXR0ZXJuID0gMS4wICsgKGhvdXJPZkRheSAtIDEwKSAqIDAuMDA4XG4gICAgfSBlbHNlIGlmIChob3VyT2ZEYXkgPj0gMTggJiYgaG91ck9mRGF5IDw9IDIyKSB7XG4gICAgICAvLyBTb2lyw6llIDogY29uc29tbWF0aW9uIG1vZMOpcsOpZSAoOTUtMTAwJSlcbiAgICAgIGRhaWx5UGF0dGVybiA9IDAuOTUgKyAoaG91ck9mRGF5IC0gMTgpICogMC4wMTI1XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYW5zaXRpb24gOiBjb25zb21tYXRpb24gbW95ZW5uZSAoOTAtMTAwJSlcbiAgICAgIGRhaWx5UGF0dGVybiA9IDAuOSArIE1hdGguYWJzKGhvdXJPZkRheSAtIDEyKSAqIDAuMDA4XG4gICAgfVxuICAgIFxuICAgIC8vIFZhcmlhdGlvbiBhbMOpYXRvaXJlIGF2ZWMgdGVuZGFuY2UgbGlzc2VcbiAgICBjb25zdCByYW5kb21WYXJpYXRpb24gPSAwLjk3ICsgTWF0aC5yYW5kb20oKSAqIDAuMDZcbiAgICAvLyBBam91dCBkJ3VuZSBwZXRpdGUgb3NjaWxsYXRpb24gcG91ciByZW5kcmUgbGEgY291cmJlIHBsdXMgbmF0dXJlbGxlXG4gICAgY29uc3Qgc21vb3RoV2F2ZSA9IE1hdGguc2luKChpIC8gMjQpICogTWF0aC5QSSAqIDQpICogMC4wMlxuICAgIFxuICAgIGNvbnN0IHZhbHVlID0gYmFzZVBvd2VyICogZGFpbHlQYXR0ZXJuICogcmFuZG9tVmFyaWF0aW9uICsgc21vb3RoV2F2ZSAqIGJhc2VQb3dlclxuICAgIGRhdGEucHVzaCh7IGhvdXI6IGksIHZhbHVlOiBNYXRoLnJvdW5kKHZhbHVlICogMTApIC8gMTAgfSlcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVCbG9ja1Bvd2VyRGlzdHJpYnV0aW9uKCk6IEJsb2NrRGF0YVBvaW50W10ge1xuICBjb25zdCBibG9ja3MgPSBbXG4gICAgeyBpZDogJ2Jsb2NrLTEnLCBuYW1lOiAnQmxvY2sgMScgfSxcbiAgICB7IGlkOiAnYmxvY2stMicsIG5hbWU6ICdCbG9jayAyJyB9LFxuICAgIHsgaWQ6ICdibG9jay0zJywgbmFtZTogJ0Jsb2NrIDMnIH0sXG4gICAgeyBpZDogJ2Jsb2NrLTQnLCBuYW1lOiAnQmxvY2sgNCcgfVxuICBdXG4gIFxuICAvLyBWYWxldXJzIG1vY2t1cCByw6lhbGlzdGVzIGV0IMOpcXVpbGlicsOpZXMgcG91ciBjaGFxdWUgYmxvY1xuICBjb25zdCBiYXNlVmFsdWVzID0gWzI1LjgsIDI1LjQsIDI1LjYsIDI1LjJdIC8vIEzDqWfDqHJlbWVudCBkaWZmw6lyZW50ZXMgcG91ciBtb250cmVyIGxhIHZhcmlhdGlvblxuICBcbiAgcmV0dXJuIGJsb2Nrcy5tYXAoKGJsb2NrLCBpbmRleCkgPT4gKHtcbiAgICBibG9ja0lkOiBibG9jay5pZCxcbiAgICBibG9ja05hbWU6IGJsb2NrLm5hbWUsXG4gICAgdmFsdWU6IGJhc2VWYWx1ZXNbaW5kZXhdICsgKE1hdGgucmFuZG9tKCkgKiAwLjQgLSAwLjIpIC8vIFBldGl0ZSB2YXJpYXRpb24gYXV0b3VyIGRlIGxhIHZhbGV1ciBkZSBiYXNlXG4gIH0pKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVWb2x0YWdlQ3VycmVudERhdGEoKTogSG91cmx5RGF0YVBvaW50W10ge1xuICBjb25zdCBkYXRhOiBIb3VybHlEYXRhUG9pbnRbXSA9IFtdXG4gIGNvbnN0IGJhc2VWb2x0YWdlID0gMzMgLy8ga1ZcbiAgY29uc3QgaG91cnMgPSAyNFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG91cnM7IGkrKykge1xuICAgIC8vIFRlbnNpb24gYXZlYyB2YXJpYXRpb24gcsOpYWxpc3RlIDogbMOpZ8OocmUgYmFpc3NlIGVuIGpvdXJuw6llIChjaGFyZ2UgcsOpc2VhdSlcbiAgICBjb25zdCBob3VyT2ZEYXkgPSBpXG4gICAgbGV0IHZvbHRhZ2VWYXJpYXRpb24gPSAwXG4gICAgXG4gICAgaWYgKGhvdXJPZkRheSA+PSA4ICYmIGhvdXJPZkRheSA8PSAxOCkge1xuICAgICAgLy8gSm91cm7DqWUgOiBsw6lnw6hyZSBiYWlzc2UgZHVlIMOgIGxhIGNoYXJnZSByw6lzZWF1ICgtMC4xNSDDoCAtMC4wNSBrVilcbiAgICAgIHZvbHRhZ2VWYXJpYXRpb24gPSAtMC4xNSArIChob3VyT2ZEYXkgLSA4KSAqIDAuMDFcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTnVpdCA6IHRlbnNpb24gcGx1cyBzdGFibGUsIGzDqWfDqHJlbWVudCBwbHVzIMOpbGV2w6llXG4gICAgICB2b2x0YWdlVmFyaWF0aW9uID0gMC4wNSAtIE1hdGguYWJzKGhvdXJPZkRheSAtIDEyKSAqIDAuMDAzXG4gICAgfVxuICAgIFxuICAgIC8vIFZhcmlhdGlvbiBhbMOpYXRvaXJlIGZpbmVcbiAgICBjb25zdCByYW5kb21Ob2lzZSA9IChNYXRoLnJhbmRvbSgpICogMC4xNSAtIDAuMDc1KVxuICAgIC8vIE9zY2lsbGF0aW9uIHRyw6hzIGzDqWfDqHJlIHBvdXIgY291cmJlIG5hdHVyZWxsZVxuICAgIGNvbnN0IG1pY3JvV2F2ZSA9IE1hdGguc2luKChpIC8gMjQpICogTWF0aC5QSSAqIDYpICogMC4wM1xuICAgIFxuICAgIGNvbnN0IHZvbHRhZ2UgPSBiYXNlVm9sdGFnZSArIHZvbHRhZ2VWYXJpYXRpb24gKyByYW5kb21Ob2lzZSArIG1pY3JvV2F2ZVxuICAgIGRhdGEucHVzaCh7IGhvdXI6IGksIHZhbHVlOiBNYXRoLnJvdW5kKHZvbHRhZ2UgKiAxMCkgLyAxMCB9KVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50RWxlY3RyaWNpdHlNZXRyaWNzKCkge1xuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gIGNvbnN0IGN1cnJlbnRIb3VyID0gbm93LmdldEhvdXJzKClcbiAgXG4gIC8vIFBhdHRlcm4gcsOpYWxpc3RlIHNlbG9uIGwnaGV1cmVcbiAgbGV0IHBvd2VyTXVsdGlwbGllciA9IDEuMFxuICBpZiAoY3VycmVudEhvdXIgPj0gMiAmJiBjdXJyZW50SG91ciA8PSA2KSB7XG4gICAgcG93ZXJNdWx0aXBsaWVyID0gMC44OCArIChjdXJyZW50SG91ciAtIDIpICogMC4wM1xuICB9IGVsc2UgaWYgKGN1cnJlbnRIb3VyID49IDEwICYmIGN1cnJlbnRIb3VyIDw9IDE2KSB7XG4gICAgcG93ZXJNdWx0aXBsaWVyID0gMS4wICsgKGN1cnJlbnRIb3VyIC0gMTApICogMC4wMDZcbiAgfSBlbHNlIGlmIChjdXJyZW50SG91ciA+PSAxOCAmJiBjdXJyZW50SG91ciA8PSAyMikge1xuICAgIHBvd2VyTXVsdGlwbGllciA9IDAuOTYgKyAoY3VycmVudEhvdXIgLSAxOCkgKiAwLjAxXG4gIH0gZWxzZSB7XG4gICAgcG93ZXJNdWx0aXBsaWVyID0gMC45MiArIE1hdGguYWJzKGN1cnJlbnRIb3VyIC0gMTIpICogMC4wMDZcbiAgfVxuICBcbiAgY29uc3QgYmFzZVBvd2VyID0gMTAyLjRcbiAgY29uc3QgY3VycmVudFBvd2VyID0gYmFzZVBvd2VyICogcG93ZXJNdWx0aXBsaWVyICsgKE1hdGgucmFuZG9tKCkgKiAxLjUgLSAwLjc1KVxuICBcbiAgLy8gVGVuc2lvbiBjb3Jyw6lsw6llIGF2ZWMgbGEgY2hhcmdlXG4gIGNvbnN0IHZvbHRhZ2VWYXJpYXRpb24gPSBjdXJyZW50SG91ciA+PSA4ICYmIGN1cnJlbnRIb3VyIDw9IDE4ID8gLTAuMTIgOiAwLjA1XG4gIGNvbnN0IHZvbHRhZ2UgPSAzMyArIHZvbHRhZ2VWYXJpYXRpb24gKyAoTWF0aC5yYW5kb20oKSAqIDAuMiAtIDAuMSlcbiAgXG4gIGNvbnN0IGN1cnJlbnQgPSBNYXRoLnJvdW5kKChjdXJyZW50UG93ZXIgKiAxMDAwMDAwKSAvICgxLjczMiAqIDMzMDAwKSlcbiAgY29uc3QgZWZmaWNpZW5jeSA9IDkzICsgTWF0aC5yYW5kb20oKSAqIDQuNSAvLyA5My05Ny41JVxuICBjb25zdCBjb3N0UGVySG91ciA9IGN1cnJlbnRQb3dlciAqIDAuMDUyIC8vIENvw7t0IGzDqWfDqHJlbWVudCB2YXJpYWJsZVxuXG4gIHJldHVybiB7XG4gICAgdG90YWxQb3dlck1XOiBNYXRoLnJvdW5kKGN1cnJlbnRQb3dlciAqIDEwKSAvIDEwLFxuICAgIHZvbHRhZ2VLVjogTWF0aC5yb3VuZCh2b2x0YWdlICogMTApIC8gMTAsXG4gICAgY3VycmVudEE6IGN1cnJlbnQsXG4gICAgZWZmaWNpZW5jeVBlcmNlbnQ6IE1hdGgucm91bmQoZWZmaWNpZW5jeSAqIDEwKSAvIDEwLFxuICAgIGNvc3RQZXJIb3VyVVNEOiBNYXRoLnJvdW5kKGNvc3RQZXJIb3VyICogMTAwKSAvIDEwMFxuICB9XG59XG5cbi8vIEJpdGNvaW4gbWluaW5nIHRyYWNraW5nIGRhdGFcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZTI0SG91ckhhc2hyYXRlKCk6IEhvdXJseURhdGFQb2ludFtdIHtcbiAgY29uc3QgZGF0YTogSG91cmx5RGF0YVBvaW50W10gPSBbXVxuICBjb25zdCBiYXNlSGFzaHJhdGUgPSA1MDAgLy8gVEgvcyAoZXN0aW1hdGVkIGZvciA2NCBjb250YWluZXJzIGF0IH43LjggVEgvcyBlYWNoKVxuICBjb25zdCBob3VycyA9IDI0XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3VyczsgaSsrKSB7XG4gICAgLy8gSGFzaHJhdGUgYXZlYyB2YXJpYXRpb25zIHLDqWFsaXN0ZXMgOiBsw6lnw6hyZSBiYWlzc2UgZW4gam91cm7DqWUgKHRlbXDDqXJhdHVyZSlcbiAgICBjb25zdCBob3VyT2ZEYXkgPSBpXG4gICAgbGV0IGVmZmljaWVuY3lGYWN0b3IgPSAxLjBcbiAgICBcbiAgICAvLyBMw6lnw6hyZSB2YXJpYXRpb24gc2Vsb24gbCdoZXVyZSAodGVtcMOpcmF0dXJlIGFtYmlhbnRlIGFmZmVjdGUgbMOpZ8OocmVtZW50KVxuICAgIGlmIChob3VyT2ZEYXkgPj0gMTIgJiYgaG91ck9mRGF5IDw9IDE4KSB7XG4gICAgICAvLyBBcHLDqHMtbWlkaSA6IGzDqWfDqHJlIGJhaXNzZSBkdWUgw6AgdGVtcMOpcmF0dXJlICg5OC05OSUpXG4gICAgICBlZmZpY2llbmN5RmFjdG9yID0gMC45OCArIChob3VyT2ZEYXkgLSAxMikgKiAwLjAwMTdcbiAgICB9IGVsc2UgaWYgKGhvdXJPZkRheSA+PSAyICYmIGhvdXJPZkRheSA8PSA2KSB7XG4gICAgICAvLyBOdWl0IDogcGVyZm9ybWFuY2Ugb3B0aW1hbGUgKDEwMC0xMDElKVxuICAgICAgZWZmaWNpZW5jeUZhY3RvciA9IDEuMCArIChob3VyT2ZEYXkgLSAyKSAqIDAuMDAyNVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdXRyZXMgaGV1cmVzIDogcGVyZm9ybWFuY2Ugbm9ybWFsZSAoOTktMTAwJSlcbiAgICAgIGVmZmljaWVuY3lGYWN0b3IgPSAwLjk5ICsgTWF0aC5hYnMoaG91ck9mRGF5IC0gMTIpICogMC4wMDA4XG4gICAgfVxuICAgIFxuICAgIC8vIFZhcmlhdGlvbiBhbMOpYXRvaXJlIGZpbmVcbiAgICBjb25zdCByYW5kb21WYXJpYXRpb24gPSAwLjk4NSArIE1hdGgucmFuZG9tKCkgKiAwLjAzXG4gICAgLy8gUGV0aXRlIG9zY2lsbGF0aW9uIHBvdXIgY291cmJlIG5hdHVyZWxsZVxuICAgIGNvbnN0IHNtb290aFdhdmUgPSBNYXRoLmNvcygoaSAvIDI0KSAqIE1hdGguUEkgKiAzKSAqIDAuMDE1XG4gICAgXG4gICAgY29uc3QgdmFsdWUgPSBiYXNlSGFzaHJhdGUgKiBlZmZpY2llbmN5RmFjdG9yICogcmFuZG9tVmFyaWF0aW9uICsgc21vb3RoV2F2ZSAqIGJhc2VIYXNocmF0ZVxuICAgIGRhdGEucHVzaCh7IGhvdXI6IGksIHZhbHVlOiBNYXRoLnJvdW5kKHZhbHVlICogMTApIC8gMTAgfSlcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGUyNEhvdXJSZXZlbnVlKCk6IEhvdXJseURhdGFQb2ludFtdIHtcbiAgY29uc3QgZGF0YTogSG91cmx5RGF0YVBvaW50W10gPSBbXVxuICBjb25zdCBiYXNlUmV2ZW51ZSA9IDAuNSAvLyBCVEMgcGVyIGRheSAoZXN0aW1hdGVkKVxuICBjb25zdCBob3VycyA9IDI0XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3VyczsgaSsrKSB7XG4gICAgLy8gUmV2ZW51cyBhdmVjIHBhdHRlcm4gcsOpYWxpc3RlIDogY29ycsOpbMOpIGF2ZWMgaGFzaHJhdGVcbiAgICBjb25zdCBob3VyT2ZEYXkgPSBpXG4gICAgXG4gICAgLy8gUGF0dGVybiBzaW1pbGFpcmUgYXUgaGFzaHJhdGUgKHBlcmZvcm1hbmNlIGFmZmVjdGUgbGVzIHJldmVudXMpXG4gICAgbGV0IHJldmVudWVGYWN0b3IgPSAxLjBcbiAgICBpZiAoaG91ck9mRGF5ID49IDEyICYmIGhvdXJPZkRheSA8PSAxOCkge1xuICAgICAgcmV2ZW51ZUZhY3RvciA9IDAuOTcgKyAoaG91ck9mRGF5IC0gMTIpICogMC4wMDJcbiAgICB9IGVsc2UgaWYgKGhvdXJPZkRheSA+PSAyICYmIGhvdXJPZkRheSA8PSA2KSB7XG4gICAgICByZXZlbnVlRmFjdG9yID0gMS4wICsgKGhvdXJPZkRheSAtIDIpICogMC4wMDNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV2ZW51ZUZhY3RvciA9IDAuOTggKyBNYXRoLmFicyhob3VyT2ZEYXkgLSAxMikgKiAwLjAwMVxuICAgIH1cbiAgICBcbiAgICAvLyBWYXJpYXRpb24gYWzDqWF0b2lyZSBwbHVzIGltcG9ydGFudGUgKG1hcmNow6kgQml0Y29pbiB2b2xhdGlsZSlcbiAgICBjb25zdCBtYXJrZXRWb2xhdGlsaXR5ID0gMC45MiArIE1hdGgucmFuZG9tKCkgKiAwLjE2XG4gICAgLy8gT3NjaWxsYXRpb24gcG91ciBzaW11bGVyIGxhIHZvbGF0aWxpdMOpIGR1IG1hcmNow6lcbiAgICBjb25zdCBtYXJrZXRXYXZlID0gTWF0aC5zaW4oKGkgLyAyNCkgKiBNYXRoLlBJICogNSkgKiAwLjA0XG4gICAgXG4gICAgY29uc3QgaG91cmx5UmV2ZW51ZSA9IChiYXNlUmV2ZW51ZSAvIDI0KSAqIHJldmVudWVGYWN0b3IgKiBtYXJrZXRWb2xhdGlsaXR5XG4gICAgY29uc3QgdmFsdWUgPSBob3VybHlSZXZlbnVlICsgbWFya2V0V2F2ZSAqIChiYXNlUmV2ZW51ZSAvIDI0KVxuICAgIGRhdGEucHVzaCh7IGhvdXI6IGksIHZhbHVlOiBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwMCkgLyAxMDAwMDAwKSB9KVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVRlbXBlcmF0dXJlRGF0YSgpOiBIb3VybHlEYXRhUG9pbnRbXSB7XG4gIGNvbnN0IGRhdGE6IEhvdXJseURhdGFQb2ludFtdID0gW11cbiAgY29uc3QgYmFzZVRlbXAgPSAyNSAvLyBDZWxzaXVzIChjb29sZWQgYnkgaHlkcm8pXG4gIGNvbnN0IGhvdXJzID0gMjRcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhvdXJzOyBpKyspIHtcbiAgICBjb25zdCBob3VyT2ZEYXkgPSBpXG4gICAgXG4gICAgLy8gUGF0dGVybiBkZSB0ZW1ww6lyYXR1cmUgcsOpYWxpc3RlIDogcGx1cyBmcm9pZCBsYSBudWl0LCBwbHVzIGNoYXVkIGVuIGpvdXJuw6llXG4gICAgbGV0IGFtYmllbnRUZW1wID0gYmFzZVRlbXBcbiAgICBcbiAgICBpZiAoaG91ck9mRGF5ID49IDIgJiYgaG91ck9mRGF5IDw9IDYpIHtcbiAgICAgIC8vIE51aXQgOiB0ZW1ww6lyYXR1cmUgcGx1cyBiYXNzZSAoMjAtMjPCsEMpXG4gICAgICBhbWJpZW50VGVtcCA9IDIwICsgKGhvdXJPZkRheSAtIDIpICogMC43NVxuICAgIH0gZWxzZSBpZiAoaG91ck9mRGF5ID49IDEyICYmIGhvdXJPZkRheSA8PSAxNikge1xuICAgICAgLy8gQXByw6hzLW1pZGkgOiB0ZW1ww6lyYXR1cmUgcGx1cyDDqWxldsOpZSAoMjctMzDCsEMpXG4gICAgICBhbWJpZW50VGVtcCA9IDI3ICsgKGhvdXJPZkRheSAtIDEyKSAqIDAuNzVcbiAgICB9IGVsc2UgaWYgKGhvdXJPZkRheSA+PSA4ICYmIGhvdXJPZkRheSA8PSAxMSkge1xuICAgICAgLy8gTWF0aW4gOiBtb250w6llIHByb2dyZXNzaXZlICgyMy0yN8KwQylcbiAgICAgIGFtYmllbnRUZW1wID0gMjMgKyAoaG91ck9mRGF5IC0gOCkgKiAxLjMzXG4gICAgfSBlbHNlIGlmIChob3VyT2ZEYXkgPj0gMTcgJiYgaG91ck9mRGF5IDw9IDIxKSB7XG4gICAgICAvLyBTb2lyIDogZGVzY2VudGUgcHJvZ3Jlc3NpdmUgKDMwLTI0wrBDKVxuICAgICAgYW1iaWVudFRlbXAgPSAzMCAtIChob3VyT2ZEYXkgLSAxNykgKiAxLjVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJhbnNpdGlvbiA6IGludGVycG9sYXRpb25cbiAgICAgIGFtYmllbnRUZW1wID0gMjQgKyBNYXRoLnNpbigoaG91ck9mRGF5IC8gMjQpICogTWF0aC5QSSAqIDIpICogNFxuICAgIH1cbiAgICBcbiAgICAvLyBWYXJpYXRpb24gYWzDqWF0b2lyZSBmaW5lXG4gICAgY29uc3QgcmFuZG9tVmFyaWF0aW9uID0gKE1hdGgucmFuZG9tKCkgKiAxLjUgLSAwLjc1KVxuICAgIC8vIE9zY2lsbGF0aW9uIHRyw6hzIGzDqWfDqHJlXG4gICAgY29uc3QgbWljcm9XYXZlID0gTWF0aC5jb3MoKGkgLyAyNCkgKiBNYXRoLlBJICogNCkgKiAwLjVcbiAgICBcbiAgICBjb25zdCB2YWx1ZSA9IGFtYmllbnRUZW1wICsgcmFuZG9tVmFyaWF0aW9uICsgbWljcm9XYXZlXG4gICAgZGF0YS5wdXNoKHsgaG91cjogaSwgdmFsdWU6IE1hdGgucm91bmQodmFsdWUgKiAxMCkgLyAxMCB9KVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50TWluaW5nTWV0cmljcygpIHtcbiAgY29uc3QgaGFzaHJhdGUgPSA1MDAgKyAoTWF0aC5yYW5kb20oKSAqIDIwIC0gMTApIC8vIFRIL3NcbiAgY29uc3QgYWN0aXZlQ29udGFpbmVycyA9IDY0IC0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMikgLy8gNjMtNjQgYWN0aXZlXG4gIGNvbnN0IGF2Z1RlbXBlcmF0dXJlID0gMjUgKyAoTWF0aC5yYW5kb20oKSAqIDUgLSAyLjUpIC8vIDIyLjUtMjcuNcKwQ1xuICBjb25zdCBlZmZpY2llbmN5ID0gMjUgKyAoTWF0aC5yYW5kb20oKSAqIDIpIC8vIEovVEggKGpvdWxlcyBwZXIgdGVyYWhhc2gpXG4gIGNvbnN0IGRhaWx5UmV2ZW51ZUJUQyA9IDAuNSArIChNYXRoLnJhbmRvbSgpICogMC4xIC0gMC4wNSlcbiAgY29uc3QgYnRjUHJpY2UgPSA0NTAwMCAvLyBVU0QgKGV4YW1wbGUpXG4gIGNvbnN0IGRhaWx5UmV2ZW51ZVVTRCA9IGRhaWx5UmV2ZW51ZUJUQyAqIGJ0Y1ByaWNlXG5cbiAgcmV0dXJuIHtcbiAgICBoYXNocmF0ZVRIczogTWF0aC5yb3VuZChoYXNocmF0ZSAqIDEwKSAvIDEwLFxuICAgIGFjdGl2ZUNvbnRhaW5lcnMsXG4gICAgYXZnVGVtcGVyYXR1cmU6IE1hdGgucm91bmQoYXZnVGVtcGVyYXR1cmUgKiAxMCkgLyAxMCxcbiAgICBlZmZpY2llbmN5SlRIOiBNYXRoLnJvdW5kKGVmZmljaWVuY3kgKiAxMCkgLyAxMCxcbiAgICBkYWlseVJldmVudWVCVEM6IE1hdGgucm91bmQoZGFpbHlSZXZlbnVlQlRDICogMTAwMDAwMCkgLyAxMDAwMDAwLFxuICAgIGRhaWx5UmV2ZW51ZVVTRDogTWF0aC5yb3VuZChkYWlseVJldmVudWVVU0QpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJnZW5lcmF0ZTI0SG91ckNvbnN1bXB0aW9uIiwiZGF0YSIsImJhc2VQb3dlciIsImhvdXJzIiwibm93IiwiRGF0ZSIsImN1cnJlbnRIb3VyIiwiZ2V0SG91cnMiLCJpIiwiaG91ck9mRGF5IiwiZGFpbHlQYXR0ZXJuIiwiTWF0aCIsImFicyIsInJhbmRvbVZhcmlhdGlvbiIsInJhbmRvbSIsInNtb290aFdhdmUiLCJzaW4iLCJQSSIsInZhbHVlIiwicHVzaCIsImhvdXIiLCJyb3VuZCIsImdlbmVyYXRlQmxvY2tQb3dlckRpc3RyaWJ1dGlvbiIsImJsb2NrcyIsImlkIiwibmFtZSIsImJhc2VWYWx1ZXMiLCJtYXAiLCJibG9jayIsImluZGV4IiwiYmxvY2tJZCIsImJsb2NrTmFtZSIsImdlbmVyYXRlVm9sdGFnZUN1cnJlbnREYXRhIiwiYmFzZVZvbHRhZ2UiLCJ2b2x0YWdlVmFyaWF0aW9uIiwicmFuZG9tTm9pc2UiLCJtaWNyb1dhdmUiLCJ2b2x0YWdlIiwiZ2V0Q3VycmVudEVsZWN0cmljaXR5TWV0cmljcyIsInBvd2VyTXVsdGlwbGllciIsImN1cnJlbnRQb3dlciIsImN1cnJlbnQiLCJlZmZpY2llbmN5IiwiY29zdFBlckhvdXIiLCJ0b3RhbFBvd2VyTVciLCJ2b2x0YWdlS1YiLCJjdXJyZW50QSIsImVmZmljaWVuY3lQZXJjZW50IiwiY29zdFBlckhvdXJVU0QiLCJnZW5lcmF0ZTI0SG91ckhhc2hyYXRlIiwiYmFzZUhhc2hyYXRlIiwiZWZmaWNpZW5jeUZhY3RvciIsImNvcyIsImdlbmVyYXRlMjRIb3VyUmV2ZW51ZSIsImJhc2VSZXZlbnVlIiwicmV2ZW51ZUZhY3RvciIsIm1hcmtldFZvbGF0aWxpdHkiLCJtYXJrZXRXYXZlIiwiaG91cmx5UmV2ZW51ZSIsIm1heCIsImdlbmVyYXRlVGVtcGVyYXR1cmVEYXRhIiwiYmFzZVRlbXAiLCJhbWJpZW50VGVtcCIsImdldEN1cnJlbnRNaW5pbmdNZXRyaWNzIiwiaGFzaHJhdGUiLCJhY3RpdmVDb250YWluZXJzIiwiZmxvb3IiLCJhdmdUZW1wZXJhdHVyZSIsImRhaWx5UmV2ZW51ZUJUQyIsImJ0Y1ByaWNlIiwiZGFpbHlSZXZlbnVlVVNEIiwiaGFzaHJhdGVUSHMiLCJlZmZpY2llbmN5SlRIIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/mockData.ts\n"));

/***/ })

});