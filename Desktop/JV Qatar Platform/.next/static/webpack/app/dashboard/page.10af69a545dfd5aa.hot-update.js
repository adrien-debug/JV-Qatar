"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/mockData.ts":
/*!*****************************!*\
  !*** ./src/lib/mockData.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generate24HourConsumption: function() { return /* binding */ generate24HourConsumption; },\n/* harmony export */   generate24HourHashrate: function() { return /* binding */ generate24HourHashrate; },\n/* harmony export */   generate24HourRevenue: function() { return /* binding */ generate24HourRevenue; },\n/* harmony export */   generateBlockPowerDistribution: function() { return /* binding */ generateBlockPowerDistribution; },\n/* harmony export */   generateTemperatureData: function() { return /* binding */ generateTemperatureData; },\n/* harmony export */   generateVoltageCurrentData: function() { return /* binding */ generateVoltageCurrentData; },\n/* harmony export */   getCurrentElectricityMetrics: function() { return /* binding */ getCurrentElectricityMetrics; },\n/* harmony export */   getCurrentMiningMetrics: function() { return /* binding */ getCurrentMiningMetrics; }\n/* harmony export */ });\n/**\n * Mock data generators for dashboard tracking\n * Simulates realistic data for electricity and Bitcoin mining tracking\n */ // Electricity tracking data\nfunction generate24HourConsumption() {\n    const data = [];\n    const basePower = 102.4 // MW\n    ;\n    const hours = 24;\n    const now = new Date();\n    const currentHour = now.getHours();\n    for(let i = 0; i < hours; i++){\n        // Pattern quotidien réaliste : plus bas la nuit (2-6h), pic en journée (10-16h)\n        const hourOfDay = (currentHour + i) % 24;\n        let dailyPattern = 1.0;\n        if (hourOfDay >= 2 && hourOfDay <= 6) {\n            // Nuit : consommation réduite (85-95%)\n            dailyPattern = 0.85 + (hourOfDay - 2) * 0.025;\n        } else if (hourOfDay >= 10 && hourOfDay <= 16) {\n            // Journée : pic de consommation (100-105%)\n            dailyPattern = 1.0 + (hourOfDay - 10) * 0.008;\n        } else if (hourOfDay >= 18 && hourOfDay <= 22) {\n            // Soirée : consommation modérée (95-100%)\n            dailyPattern = 0.95 + (hourOfDay - 18) * 0.0125;\n        } else {\n            // Transition : consommation moyenne (90-100%)\n            dailyPattern = 0.9 + Math.abs(hourOfDay - 12) * 0.008;\n        }\n        // Variation aléatoire avec tendance lisse\n        const randomVariation = 0.97 + Math.random() * 0.06;\n        // Ajout d'une petite oscillation pour rendre la courbe plus naturelle\n        const smoothWave = Math.sin(i / 24 * Math.PI * 4) * 0.02;\n        const value = basePower * dailyPattern * randomVariation + smoothWave * basePower;\n        data.push({\n            hour: i,\n            value: Math.round(value * 10) / 10\n        });\n    }\n    return data;\n}\nfunction generateBlockPowerDistribution() {\n    const blocks = [\n        {\n            id: \"block-1\",\n            name: \"Block 1\"\n        },\n        {\n            id: \"block-2\",\n            name: \"Block 2\"\n        },\n        {\n            id: \"block-3\",\n            name: \"Block 3\"\n        },\n        {\n            id: \"block-4\",\n            name: \"Block 4\"\n        }\n    ];\n    // Valeurs mockup réalistes et équilibrées pour chaque bloc\n    const baseValues = [\n        25.8,\n        25.4,\n        25.6,\n        25.2\n    ] // Légèrement différentes pour montrer la variation\n    ;\n    return blocks.map((block, index)=>({\n            blockId: block.id,\n            blockName: block.name,\n            value: baseValues[index] + (Math.random() * 0.4 - 0.2 // Petite variation autour de la valeur de base\n            )\n        }));\n}\nfunction generateVoltageCurrentData() {\n    const data = [];\n    const baseVoltage = 33 // kV\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        // Voltage stays relatively stable (32.8 to 33.2 kV)\n        const voltage = baseVoltage + (Math.random() * 0.4 - 0.2);\n        data.push({\n            hour: i,\n            value: Math.round(voltage * 10) / 10\n        });\n    }\n    return data;\n}\nfunction getCurrentElectricityMetrics() {\n    const currentPower = 102.4 + (Math.random() * 2 - 1);\n    const voltage = 33 + (Math.random() * 0.4 - 0.2);\n    const current = Math.round(currentPower * 1000000 / (1.732 * 33000));\n    const efficiency = 92 + Math.random() * 5 // 92-97%\n    ;\n    const costPerHour = currentPower * 0.05 // Assuming ~0.05 USD/kWh\n    ;\n    return {\n        totalPowerMW: Math.round(currentPower * 10) / 10,\n        voltageKV: Math.round(voltage * 10) / 10,\n        currentA: current,\n        efficiencyPercent: Math.round(efficiency * 10) / 10,\n        costPerHourUSD: Math.round(costPerHour * 100) / 100\n    };\n}\n// Bitcoin mining tracking data\nfunction generate24HourHashrate() {\n    const data = [];\n    const baseHashrate = 500 // TH/s (estimated for 64 containers at ~7.8 TH/s each)\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        // Small variation in hashrate (98% to 102%)\n        const variation = 0.98 + Math.random() * 0.04;\n        const value = baseHashrate * variation;\n        data.push({\n            hour: i,\n            value: Math.round(value * 10) / 10\n        });\n    }\n    return data;\n}\nfunction generate24HourRevenue() {\n    const data = [];\n    const baseRevenue = 0.5 // BTC per day (estimated)\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        // Revenue varies slightly\n        const variation = 0.95 + Math.random() * 0.1;\n        const value = baseRevenue / 24 * variation;\n        data.push({\n            hour: i,\n            value: Math.round(value * 1000000) / 1000000\n        });\n    }\n    return data;\n}\nfunction generateTemperatureData() {\n    const data = [];\n    const baseTemp = 25 // Celsius (cooled by hydro)\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        // Temperature varies with ambient (20-30°C)\n        const ambientVariation = Math.sin(i / 24 * Math.PI * 2) * 5;\n        const value = baseTemp + ambientVariation + (Math.random() * 2 - 1);\n        data.push({\n            hour: i,\n            value: Math.round(value * 10) / 10\n        });\n    }\n    return data;\n}\nfunction getCurrentMiningMetrics() {\n    const hashrate = 500 + (Math.random() * 20 - 10 // TH/s\n    );\n    const activeContainers = 64 - Math.floor(Math.random() * 2) // 63-64 active\n    ;\n    const avgTemperature = 25 + (Math.random() * 5 - 2.5 // 22.5-27.5°C\n    );\n    const efficiency = 25 + Math.random() * 2 // J/TH (joules per terahash)\n    ;\n    const dailyRevenueBTC = 0.5 + (Math.random() * 0.1 - 0.05);\n    const btcPrice = 45000 // USD (example)\n    ;\n    const dailyRevenueUSD = dailyRevenueBTC * btcPrice;\n    return {\n        hashrateTHs: Math.round(hashrate * 10) / 10,\n        activeContainers,\n        avgTemperature: Math.round(avgTemperature * 10) / 10,\n        efficiencyJTH: Math.round(efficiency * 10) / 10,\n        dailyRevenueBTC: Math.round(dailyRevenueBTC * 1000000) / 1000000,\n        dailyRevenueUSD: Math.round(dailyRevenueUSD)\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFXLE1BQU07UUFDekNDO1FBQ0FFLGdCQUFnQjlDLEtBQUtVLEtBQUssQ0FBQ29DLGlCQUFpQixNQUFNO1FBQ2xESyxlQUFlbkQsS0FBS1UsS0FBSyxDQUFDaUIsYUFBYSxNQUFNO1FBQzdDb0IsaUJBQWlCL0MsS0FBS1UsS0FBSyxDQUFDcUMsa0JBQWtCLFdBQVc7UUFDekRFLGlCQUFpQmpELEtBQUtVLEtBQUssQ0FBQ3VDO0lBQzlCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9tb2NrRGF0YS50cz9mZmZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9jayBkYXRhIGdlbmVyYXRvcnMgZm9yIGRhc2hib2FyZCB0cmFja2luZ1xuICogU2ltdWxhdGVzIHJlYWxpc3RpYyBkYXRhIGZvciBlbGVjdHJpY2l0eSBhbmQgQml0Y29pbiBtaW5pbmcgdHJhY2tpbmdcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIEhvdXJseURhdGFQb2ludCB7XG4gIGhvdXI6IG51bWJlclxuICB2YWx1ZTogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmxvY2tEYXRhUG9pbnQge1xuICBibG9ja0lkOiBzdHJpbmdcbiAgYmxvY2tOYW1lOiBzdHJpbmdcbiAgdmFsdWU6IG51bWJlclxufVxuXG4vLyBFbGVjdHJpY2l0eSB0cmFja2luZyBkYXRhXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGUyNEhvdXJDb25zdW1wdGlvbigpOiBIb3VybHlEYXRhUG9pbnRbXSB7XG4gIGNvbnN0IGRhdGE6IEhvdXJseURhdGFQb2ludFtdID0gW11cbiAgY29uc3QgYmFzZVBvd2VyID0gMTAyLjQgLy8gTVdcbiAgY29uc3QgaG91cnMgPSAyNFxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gIGNvbnN0IGN1cnJlbnRIb3VyID0gbm93LmdldEhvdXJzKClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhvdXJzOyBpKyspIHtcbiAgICAvLyBQYXR0ZXJuIHF1b3RpZGllbiByw6lhbGlzdGUgOiBwbHVzIGJhcyBsYSBudWl0ICgyLTZoKSwgcGljIGVuIGpvdXJuw6llICgxMC0xNmgpXG4gICAgY29uc3QgaG91ck9mRGF5ID0gKGN1cnJlbnRIb3VyICsgaSkgJSAyNFxuICAgIGxldCBkYWlseVBhdHRlcm4gPSAxLjBcbiAgICBcbiAgICBpZiAoaG91ck9mRGF5ID49IDIgJiYgaG91ck9mRGF5IDw9IDYpIHtcbiAgICAgIC8vIE51aXQgOiBjb25zb21tYXRpb24gcsOpZHVpdGUgKDg1LTk1JSlcbiAgICAgIGRhaWx5UGF0dGVybiA9IDAuODUgKyAoaG91ck9mRGF5IC0gMikgKiAwLjAyNVxuICAgIH0gZWxzZSBpZiAoaG91ck9mRGF5ID49IDEwICYmIGhvdXJPZkRheSA8PSAxNikge1xuICAgICAgLy8gSm91cm7DqWUgOiBwaWMgZGUgY29uc29tbWF0aW9uICgxMDAtMTA1JSlcbiAgICAgIGRhaWx5UGF0dGVybiA9IDEuMCArIChob3VyT2ZEYXkgLSAxMCkgKiAwLjAwOFxuICAgIH0gZWxzZSBpZiAoaG91ck9mRGF5ID49IDE4ICYmIGhvdXJPZkRheSA8PSAyMikge1xuICAgICAgLy8gU29pcsOpZSA6IGNvbnNvbW1hdGlvbiBtb2TDqXLDqWUgKDk1LTEwMCUpXG4gICAgICBkYWlseVBhdHRlcm4gPSAwLjk1ICsgKGhvdXJPZkRheSAtIDE4KSAqIDAuMDEyNVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmFuc2l0aW9uIDogY29uc29tbWF0aW9uIG1veWVubmUgKDkwLTEwMCUpXG4gICAgICBkYWlseVBhdHRlcm4gPSAwLjkgKyBNYXRoLmFicyhob3VyT2ZEYXkgLSAxMikgKiAwLjAwOFxuICAgIH1cbiAgICBcbiAgICAvLyBWYXJpYXRpb24gYWzDqWF0b2lyZSBhdmVjIHRlbmRhbmNlIGxpc3NlXG4gICAgY29uc3QgcmFuZG9tVmFyaWF0aW9uID0gMC45NyArIE1hdGgucmFuZG9tKCkgKiAwLjA2XG4gICAgLy8gQWpvdXQgZCd1bmUgcGV0aXRlIG9zY2lsbGF0aW9uIHBvdXIgcmVuZHJlIGxhIGNvdXJiZSBwbHVzIG5hdHVyZWxsZVxuICAgIGNvbnN0IHNtb290aFdhdmUgPSBNYXRoLnNpbigoaSAvIDI0KSAqIE1hdGguUEkgKiA0KSAqIDAuMDJcbiAgICBcbiAgICBjb25zdCB2YWx1ZSA9IGJhc2VQb3dlciAqIGRhaWx5UGF0dGVybiAqIHJhbmRvbVZhcmlhdGlvbiArIHNtb290aFdhdmUgKiBiYXNlUG93ZXJcbiAgICBkYXRhLnB1c2goeyBob3VyOiBpLCB2YWx1ZTogTWF0aC5yb3VuZCh2YWx1ZSAqIDEwKSAvIDEwIH0pXG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQmxvY2tQb3dlckRpc3RyaWJ1dGlvbigpOiBCbG9ja0RhdGFQb2ludFtdIHtcbiAgY29uc3QgYmxvY2tzID0gW1xuICAgIHsgaWQ6ICdibG9jay0xJywgbmFtZTogJ0Jsb2NrIDEnIH0sXG4gICAgeyBpZDogJ2Jsb2NrLTInLCBuYW1lOiAnQmxvY2sgMicgfSxcbiAgICB7IGlkOiAnYmxvY2stMycsIG5hbWU6ICdCbG9jayAzJyB9LFxuICAgIHsgaWQ6ICdibG9jay00JywgbmFtZTogJ0Jsb2NrIDQnIH1cbiAgXVxuICBcbiAgLy8gVmFsZXVycyBtb2NrdXAgcsOpYWxpc3RlcyBldCDDqXF1aWxpYnLDqWVzIHBvdXIgY2hhcXVlIGJsb2NcbiAgY29uc3QgYmFzZVZhbHVlcyA9IFsyNS44LCAyNS40LCAyNS42LCAyNS4yXSAvLyBMw6lnw6hyZW1lbnQgZGlmZsOpcmVudGVzIHBvdXIgbW9udHJlciBsYSB2YXJpYXRpb25cbiAgXG4gIHJldHVybiBibG9ja3MubWFwKChibG9jaywgaW5kZXgpID0+ICh7XG4gICAgYmxvY2tJZDogYmxvY2suaWQsXG4gICAgYmxvY2tOYW1lOiBibG9jay5uYW1lLFxuICAgIHZhbHVlOiBiYXNlVmFsdWVzW2luZGV4XSArIChNYXRoLnJhbmRvbSgpICogMC40IC0gMC4yKSAvLyBQZXRpdGUgdmFyaWF0aW9uIGF1dG91ciBkZSBsYSB2YWxldXIgZGUgYmFzZVxuICB9KSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVm9sdGFnZUN1cnJlbnREYXRhKCk6IEhvdXJseURhdGFQb2ludFtdIHtcbiAgY29uc3QgZGF0YTogSG91cmx5RGF0YVBvaW50W10gPSBbXVxuICBjb25zdCBiYXNlVm9sdGFnZSA9IDMzIC8vIGtWXG4gIGNvbnN0IGhvdXJzID0gMjRcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhvdXJzOyBpKyspIHtcbiAgICAvLyBWb2x0YWdlIHN0YXlzIHJlbGF0aXZlbHkgc3RhYmxlICgzMi44IHRvIDMzLjIga1YpXG4gICAgY29uc3Qgdm9sdGFnZSA9IGJhc2VWb2x0YWdlICsgKE1hdGgucmFuZG9tKCkgKiAwLjQgLSAwLjIpXG4gICAgZGF0YS5wdXNoKHsgaG91cjogaSwgdmFsdWU6IE1hdGgucm91bmQodm9sdGFnZSAqIDEwKSAvIDEwIH0pXG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRFbGVjdHJpY2l0eU1ldHJpY3MoKSB7XG4gIGNvbnN0IGN1cnJlbnRQb3dlciA9IDEwMi40ICsgKE1hdGgucmFuZG9tKCkgKiAyIC0gMSlcbiAgY29uc3Qgdm9sdGFnZSA9IDMzICsgKE1hdGgucmFuZG9tKCkgKiAwLjQgLSAwLjIpXG4gIGNvbnN0IGN1cnJlbnQgPSBNYXRoLnJvdW5kKChjdXJyZW50UG93ZXIgKiAxMDAwMDAwKSAvICgxLjczMiAqIDMzMDAwKSlcbiAgY29uc3QgZWZmaWNpZW5jeSA9IDkyICsgTWF0aC5yYW5kb20oKSAqIDUgLy8gOTItOTclXG4gIGNvbnN0IGNvc3RQZXJIb3VyID0gY3VycmVudFBvd2VyICogMC4wNSAvLyBBc3N1bWluZyB+MC4wNSBVU0Qva1doXG5cbiAgcmV0dXJuIHtcbiAgICB0b3RhbFBvd2VyTVc6IE1hdGgucm91bmQoY3VycmVudFBvd2VyICogMTApIC8gMTAsXG4gICAgdm9sdGFnZUtWOiBNYXRoLnJvdW5kKHZvbHRhZ2UgKiAxMCkgLyAxMCxcbiAgICBjdXJyZW50QTogY3VycmVudCxcbiAgICBlZmZpY2llbmN5UGVyY2VudDogTWF0aC5yb3VuZChlZmZpY2llbmN5ICogMTApIC8gMTAsXG4gICAgY29zdFBlckhvdXJVU0Q6IE1hdGgucm91bmQoY29zdFBlckhvdXIgKiAxMDApIC8gMTAwXG4gIH1cbn1cblxuLy8gQml0Y29pbiBtaW5pbmcgdHJhY2tpbmcgZGF0YVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlMjRIb3VySGFzaHJhdGUoKTogSG91cmx5RGF0YVBvaW50W10ge1xuICBjb25zdCBkYXRhOiBIb3VybHlEYXRhUG9pbnRbXSA9IFtdXG4gIGNvbnN0IGJhc2VIYXNocmF0ZSA9IDUwMCAvLyBUSC9zIChlc3RpbWF0ZWQgZm9yIDY0IGNvbnRhaW5lcnMgYXQgfjcuOCBUSC9zIGVhY2gpXG4gIGNvbnN0IGhvdXJzID0gMjRcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhvdXJzOyBpKyspIHtcbiAgICAvLyBTbWFsbCB2YXJpYXRpb24gaW4gaGFzaHJhdGUgKDk4JSB0byAxMDIlKVxuICAgIGNvbnN0IHZhcmlhdGlvbiA9IDAuOTggKyBNYXRoLnJhbmRvbSgpICogMC4wNFxuICAgIGNvbnN0IHZhbHVlID0gYmFzZUhhc2hyYXRlICogdmFyaWF0aW9uXG4gICAgZGF0YS5wdXNoKHsgaG91cjogaSwgdmFsdWU6IE1hdGgucm91bmQodmFsdWUgKiAxMCkgLyAxMCB9KVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZTI0SG91clJldmVudWUoKTogSG91cmx5RGF0YVBvaW50W10ge1xuICBjb25zdCBkYXRhOiBIb3VybHlEYXRhUG9pbnRbXSA9IFtdXG4gIGNvbnN0IGJhc2VSZXZlbnVlID0gMC41IC8vIEJUQyBwZXIgZGF5IChlc3RpbWF0ZWQpXG4gIGNvbnN0IGhvdXJzID0gMjRcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhvdXJzOyBpKyspIHtcbiAgICAvLyBSZXZlbnVlIHZhcmllcyBzbGlnaHRseVxuICAgIGNvbnN0IHZhcmlhdGlvbiA9IDAuOTUgKyBNYXRoLnJhbmRvbSgpICogMC4xXG4gICAgY29uc3QgdmFsdWUgPSAoYmFzZVJldmVudWUgLyAyNCkgKiB2YXJpYXRpb25cbiAgICBkYXRhLnB1c2goeyBob3VyOiBpLCB2YWx1ZTogTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwMDApIC8gMTAwMDAwMCB9KVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVRlbXBlcmF0dXJlRGF0YSgpOiBIb3VybHlEYXRhUG9pbnRbXSB7XG4gIGNvbnN0IGRhdGE6IEhvdXJseURhdGFQb2ludFtdID0gW11cbiAgY29uc3QgYmFzZVRlbXAgPSAyNSAvLyBDZWxzaXVzIChjb29sZWQgYnkgaHlkcm8pXG4gIGNvbnN0IGhvdXJzID0gMjRcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhvdXJzOyBpKyspIHtcbiAgICAvLyBUZW1wZXJhdHVyZSB2YXJpZXMgd2l0aCBhbWJpZW50ICgyMC0zMMKwQylcbiAgICBjb25zdCBhbWJpZW50VmFyaWF0aW9uID0gTWF0aC5zaW4oKGkgLyAyNCkgKiBNYXRoLlBJICogMikgKiA1XG4gICAgY29uc3QgdmFsdWUgPSBiYXNlVGVtcCArIGFtYmllbnRWYXJpYXRpb24gKyAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKVxuICAgIGRhdGEucHVzaCh7IGhvdXI6IGksIHZhbHVlOiBNYXRoLnJvdW5kKHZhbHVlICogMTApIC8gMTAgfSlcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudE1pbmluZ01ldHJpY3MoKSB7XG4gIGNvbnN0IGhhc2hyYXRlID0gNTAwICsgKE1hdGgucmFuZG9tKCkgKiAyMCAtIDEwKSAvLyBUSC9zXG4gIGNvbnN0IGFjdGl2ZUNvbnRhaW5lcnMgPSA2NCAtIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIpIC8vIDYzLTY0IGFjdGl2ZVxuICBjb25zdCBhdmdUZW1wZXJhdHVyZSA9IDI1ICsgKE1hdGgucmFuZG9tKCkgKiA1IC0gMi41KSAvLyAyMi41LTI3LjXCsENcbiAgY29uc3QgZWZmaWNpZW5jeSA9IDI1ICsgKE1hdGgucmFuZG9tKCkgKiAyKSAvLyBKL1RIIChqb3VsZXMgcGVyIHRlcmFoYXNoKVxuICBjb25zdCBkYWlseVJldmVudWVCVEMgPSAwLjUgKyAoTWF0aC5yYW5kb20oKSAqIDAuMSAtIDAuMDUpXG4gIGNvbnN0IGJ0Y1ByaWNlID0gNDUwMDAgLy8gVVNEIChleGFtcGxlKVxuICBjb25zdCBkYWlseVJldmVudWVVU0QgPSBkYWlseVJldmVudWVCVEMgKiBidGNQcmljZVxuXG4gIHJldHVybiB7XG4gICAgaGFzaHJhdGVUSHM6IE1hdGgucm91bmQoaGFzaHJhdGUgKiAxMCkgLyAxMCxcbiAgICBhY3RpdmVDb250YWluZXJzLFxuICAgIGF2Z1RlbXBlcmF0dXJlOiBNYXRoLnJvdW5kKGF2Z1RlbXBlcmF0dXJlICogMTApIC8gMTAsXG4gICAgZWZmaWNpZW5jeUpUSDogTWF0aC5yb3VuZChlZmZpY2llbmN5ICogMTApIC8gMTAsXG4gICAgZGFpbHlSZXZlbnVlQlRDOiBNYXRoLnJvdW5kKGRhaWx5UmV2ZW51ZUJUQyAqIDEwMDAwMDApIC8gMTAwMDAwMCxcbiAgICBkYWlseVJldmVudWVVU0Q6IE1hdGgucm91bmQoZGFpbHlSZXZlbnVlVVNEKVxuICB9XG59XG4iXSwibmFtZXMiOlsiZ2VuZXJhdGUyNEhvdXJDb25zdW1wdGlvbiIsImRhdGEiLCJiYXNlUG93ZXIiLCJob3VycyIsIm5vdyIsIkRhdGUiLCJjdXJyZW50SG91ciIsImdldEhvdXJzIiwiaSIsImhvdXJPZkRheSIsImRhaWx5UGF0dGVybiIsIk1hdGgiLCJhYnMiLCJyYW5kb21WYXJpYXRpb24iLCJyYW5kb20iLCJzbW9vdGhXYXZlIiwic2luIiwiUEkiLCJ2YWx1ZSIsInB1c2giLCJob3VyIiwicm91bmQiLCJnZW5lcmF0ZUJsb2NrUG93ZXJEaXN0cmlidXRpb24iLCJibG9ja3MiLCJpZCIsIm5hbWUiLCJiYXNlVmFsdWVzIiwibWFwIiwiYmxvY2siLCJpbmRleCIsImJsb2NrSWQiLCJibG9ja05hbWUiLCJnZW5lcmF0ZVZvbHRhZ2VDdXJyZW50RGF0YSIsImJhc2VWb2x0YWdlIiwidm9sdGFnZSIsImdldEN1cnJlbnRFbGVjdHJpY2l0eU1ldHJpY3MiLCJjdXJyZW50UG93ZXIiLCJjdXJyZW50IiwiZWZmaWNpZW5jeSIsImNvc3RQZXJIb3VyIiwidG90YWxQb3dlck1XIiwidm9sdGFnZUtWIiwiY3VycmVudEEiLCJlZmZpY2llbmN5UGVyY2VudCIsImNvc3RQZXJIb3VyVVNEIiwiZ2VuZXJhdGUyNEhvdXJIYXNocmF0ZSIsImJhc2VIYXNocmF0ZSIsInZhcmlhdGlvbiIsImdlbmVyYXRlMjRIb3VyUmV2ZW51ZSIsImJhc2VSZXZlbnVlIiwiZ2VuZXJhdGVUZW1wZXJhdHVyZURhdGEiLCJiYXNlVGVtcCIsImFtYmllbnRWYXJpYXRpb24iLCJnZXRDdXJyZW50TWluaW5nTWV0cmljcyIsImhhc2hyYXRlIiwiYWN0aXZlQ29udGFpbmVycyIsImZsb29yIiwiYXZnVGVtcGVyYXR1cmUiLCJkYWlseVJldmVudWVCVEMiLCJidGNQcmljZSIsImRhaWx5UmV2ZW51ZVVTRCIsImhhc2hyYXRlVEhzIiwiZWZmaWNpZW5jeUpUSCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/mockData.ts\n"));

/***/ })

});