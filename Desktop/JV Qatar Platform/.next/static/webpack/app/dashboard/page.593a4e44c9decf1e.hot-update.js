"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/mockData.ts":
/*!*****************************!*\
  !*** ./src/lib/mockData.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generate24HourConsumption: function() { return /* binding */ generate24HourConsumption; },\n/* harmony export */   generate24HourHashrate: function() { return /* binding */ generate24HourHashrate; },\n/* harmony export */   generate24HourRevenue: function() { return /* binding */ generate24HourRevenue; },\n/* harmony export */   generateBlockPowerDistribution: function() { return /* binding */ generateBlockPowerDistribution; },\n/* harmony export */   generateTemperatureData: function() { return /* binding */ generateTemperatureData; },\n/* harmony export */   generateVoltageCurrentData: function() { return /* binding */ generateVoltageCurrentData; },\n/* harmony export */   getCurrentElectricityMetrics: function() { return /* binding */ getCurrentElectricityMetrics; },\n/* harmony export */   getCurrentMiningMetrics: function() { return /* binding */ getCurrentMiningMetrics; }\n/* harmony export */ });\n/**\n * Mock data generators for dashboard tracking\n * Simulates realistic data for electricity and Bitcoin mining tracking\n */ // Electricity tracking data\nfunction generate24HourConsumption() {\n    const data = [];\n    const basePower = 102.4 // MW\n    ;\n    const hours = 24;\n    const now = new Date();\n    const currentHour = now.getHours();\n    for(let i = 0; i < hours; i++){\n        // Pattern quotidien réaliste : plus bas la nuit (2-6h), pic en journée (10-16h)\n        const hourOfDay = (currentHour + i) % 24;\n        let dailyPattern = 1.0;\n        if (hourOfDay >= 2 && hourOfDay <= 6) {\n            // Nuit : consommation réduite (85-95%)\n            dailyPattern = 0.85 + (hourOfDay - 2) * 0.025;\n        } else if (hourOfDay >= 10 && hourOfDay <= 16) {\n            // Journée : pic de consommation (100-105%)\n            dailyPattern = 1.0 + (hourOfDay - 10) * 0.008;\n        } else if (hourOfDay >= 18 && hourOfDay <= 22) {\n            // Soirée : consommation modérée (95-100%)\n            dailyPattern = 0.95 + (hourOfDay - 18) * 0.0125;\n        } else {\n            // Transition : consommation moyenne (90-100%)\n            dailyPattern = 0.9 + Math.abs(hourOfDay - 12) * 0.008;\n        }\n        // Variation aléatoire avec tendance lisse\n        const randomVariation = 0.97 + Math.random() * 0.06;\n        // Ajout d'une petite oscillation pour rendre la courbe plus naturelle\n        const smoothWave = Math.sin(i / 24 * Math.PI * 4) * 0.02;\n        const value = basePower * dailyPattern * randomVariation + smoothWave * basePower;\n        data.push({\n            hour: i,\n            value: Math.round(value * 10) / 10\n        });\n    }\n    return data;\n}\nfunction generateBlockPowerDistribution() {\n    const blocks = [\n        {\n            id: \"block-1\",\n            name: \"Block 1\"\n        },\n        {\n            id: \"block-2\",\n            name: \"Block 2\"\n        },\n        {\n            id: \"block-3\",\n            name: \"Block 3\"\n        },\n        {\n            id: \"block-4\",\n            name: \"Block 4\"\n        }\n    ];\n    // Valeurs mockup réalistes et équilibrées pour chaque bloc\n    const baseValues = [\n        25.8,\n        25.4,\n        25.6,\n        25.2\n    ] // Légèrement différentes pour montrer la variation\n    ;\n    return blocks.map((block, index)=>({\n            blockId: block.id,\n            blockName: block.name,\n            value: baseValues[index] + (Math.random() * 0.4 - 0.2 // Petite variation autour de la valeur de base\n            )\n        }));\n}\nfunction generateVoltageCurrentData() {\n    const data = [];\n    const baseVoltage = 33 // kV\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        // Tension avec variation réaliste : légère baisse en journée (charge réseau)\n        const hourOfDay = i;\n        let voltageVariation = 0;\n        if (hourOfDay >= 8 && hourOfDay <= 18) {\n            // Journée : légère baisse due à la charge réseau (-0.15 à -0.05 kV)\n            voltageVariation = -0.15 + (hourOfDay - 8) * 0.01;\n        } else {\n            // Nuit : tension plus stable, légèrement plus élevée\n            voltageVariation = 0.05 - Math.abs(hourOfDay - 12) * 0.003;\n        }\n        // Variation aléatoire fine\n        const randomNoise = Math.random() * 0.15 - 0.075;\n        // Oscillation très légère pour courbe naturelle\n        const microWave = Math.sin(i / 24 * Math.PI * 6) * 0.03;\n        const voltage = baseVoltage + voltageVariation + randomNoise + microWave;\n        data.push({\n            hour: i,\n            value: Math.round(voltage * 10) / 10\n        });\n    }\n    return data;\n}\nfunction getCurrentElectricityMetrics() {\n    const now = new Date();\n    const currentHour = now.getHours();\n    // Pattern réaliste selon l'heure\n    let powerMultiplier = 1.0;\n    if (currentHour >= 2 && currentHour <= 6) {\n        powerMultiplier = 0.88 + (currentHour - 2) * 0.03;\n    } else if (currentHour >= 10 && currentHour <= 16) {\n        powerMultiplier = 1.0 + (currentHour - 10) * 0.006;\n    } else if (currentHour >= 18 && currentHour <= 22) {\n        powerMultiplier = 0.96 + (currentHour - 18) * 0.01;\n    } else {\n        powerMultiplier = 0.92 + Math.abs(currentHour - 12) * 0.006;\n    }\n    const basePower = 102.4;\n    const currentPower = basePower * powerMultiplier + (Math.random() * 1.5 - 0.75);\n    // Tension corrélée avec la charge\n    const voltageVariation = currentHour >= 8 && currentHour <= 18 ? -0.12 : 0.05;\n    const voltage = 33 + voltageVariation + (Math.random() * 0.2 - 0.1);\n    const current = Math.round(currentPower * 1000000 / (1.732 * 33000));\n    const efficiency = 93 + Math.random() * 4.5 // 93-97.5%\n    ;\n    const costPerHour = currentPower * 0.052 // Coût légèrement variable\n    ;\n    return {\n        totalPowerMW: Math.round(currentPower * 10) / 10,\n        voltageKV: Math.round(voltage * 10) / 10,\n        currentA: current,\n        efficiencyPercent: Math.round(efficiency * 10) / 10,\n        costPerHourUSD: Math.round(costPerHour * 100) / 100\n    };\n}\n// Bitcoin mining tracking data\nfunction generate24HourHashrate() {\n    const data = [];\n    const baseHashrate = 500 // TH/s (estimated for 64 containers at ~7.8 TH/s each)\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        // Hashrate avec variations réalistes : légère baisse en journée (température)\n        const hourOfDay = i;\n        let efficiencyFactor = 1.0;\n        // Légère variation selon l'heure (température ambiante affecte légèrement)\n        if (hourOfDay >= 12 && hourOfDay <= 18) {\n            // Après-midi : légère baisse due à température (98-99%)\n            efficiencyFactor = 0.98 + (hourOfDay - 12) * 0.0017;\n        } else if (hourOfDay >= 2 && hourOfDay <= 6) {\n            // Nuit : performance optimale (100-101%)\n            efficiencyFactor = 1.0 + (hourOfDay - 2) * 0.0025;\n        } else {\n            // Autres heures : performance normale (99-100%)\n            efficiencyFactor = 0.99 + Math.abs(hourOfDay - 12) * 0.0008;\n        }\n        // Variation aléatoire fine\n        const randomVariation = 0.985 + Math.random() * 0.03;\n        // Petite oscillation pour courbe naturelle\n        const smoothWave = Math.cos(i / 24 * Math.PI * 3) * 0.015;\n        const value = baseHashrate * efficiencyFactor * randomVariation + smoothWave * baseHashrate;\n        data.push({\n            hour: i,\n            value: Math.round(value * 10) / 10\n        });\n    }\n    return data;\n}\nfunction generate24HourRevenue() {\n    const data = [];\n    const baseRevenue = 0.5 // BTC per day (estimated)\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        // Revenus avec pattern réaliste : corrélé avec hashrate\n        const hourOfDay = i;\n        // Pattern similaire au hashrate (performance affecte les revenus)\n        let revenueFactor = 1.0;\n        if (hourOfDay >= 12 && hourOfDay <= 18) {\n            revenueFactor = 0.97 + (hourOfDay - 12) * 0.002;\n        } else if (hourOfDay >= 2 && hourOfDay <= 6) {\n            revenueFactor = 1.0 + (hourOfDay - 2) * 0.003;\n        } else {\n            revenueFactor = 0.98 + Math.abs(hourOfDay - 12) * 0.001;\n        }\n        // Variation aléatoire plus importante (marché Bitcoin volatile)\n        const marketVolatility = 0.92 + Math.random() * 0.16;\n        // Oscillation pour simuler la volatilité du marché\n        const marketWave = Math.sin(i / 24 * Math.PI * 5) * 0.04;\n        const hourlyRevenue = baseRevenue / 24 * revenueFactor * marketVolatility;\n        const value = hourlyRevenue + marketWave * (baseRevenue / 24);\n        data.push({\n            hour: i,\n            value: Math.max(0, Math.round(value * 1000000) / 1000000)\n        });\n    }\n    return data;\n}\nfunction generateTemperatureData() {\n    const data = [];\n    const baseTemp = 25 // Celsius (cooled by hydro)\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        const hourOfDay = i;\n        // Pattern de température réaliste : plus froid la nuit, plus chaud en journée\n        let ambientTemp = baseTemp;\n        if (hourOfDay >= 2 && hourOfDay <= 6) {\n            // Nuit : température plus basse (20-23°C)\n            ambientTemp = 20 + (hourOfDay - 2) * 0.75;\n        } else if (hourOfDay >= 12 && hourOfDay <= 16) {\n            // Après-midi : température plus élevée (27-30°C)\n            ambientTemp = 27 + (hourOfDay - 12) * 0.75;\n        } else if (hourOfDay >= 8 && hourOfDay <= 11) {\n            // Matin : montée progressive (23-27°C)\n            ambientTemp = 23 + (hourOfDay - 8) * 1.33;\n        } else if (hourOfDay >= 17 && hourOfDay <= 21) {\n            // Soir : descente progressive (30-24°C)\n            ambientTemp = 30 - (hourOfDay - 17) * 1.5;\n        } else {\n            // Transition : interpolation\n            ambientTemp = 24 + Math.sin(hourOfDay / 24 * Math.PI * 2) * 4;\n        }\n        // Variation aléatoire fine\n        const randomVariation = Math.random() * 1.5 - 0.75;\n        // Oscillation très légère\n        const microWave = Math.cos(i / 24 * Math.PI * 4) * 0.5;\n        const value = ambientTemp + randomVariation + microWave;\n        data.push({\n            hour: i,\n            value: Math.round(value * 10) / 10\n        });\n    }\n    return data;\n}\nfunction getCurrentMiningMetrics() {\n    const now = new Date();\n    const currentHour = now.getHours();\n    // Hashrate avec pattern selon l'heure (température affecte performance)\n    let hashrateMultiplier = 1.0;\n    if (currentHour >= 12 && currentHour <= 18) {\n        hashrateMultiplier = 0.985 + (currentHour - 12) * 0.002;\n    } else if (currentHour >= 2 && currentHour <= 6) {\n        hashrateMultiplier = 1.002 + (currentHour - 2) * 0.0005;\n    } else {\n        hashrateMultiplier = 0.995 + Math.abs(currentHour - 12) * 0.0003;\n    }\n    const baseHashrate = 500;\n    const hashrate = baseHashrate * hashrateMultiplier + (Math.random() * 15 - 7.5);\n    // Conteneurs actifs (rarement tous en panne)\n    const activeContainers = 64 - Math.floor(Math.random() * 1.5) // 63-64 active\n    ;\n    // Température selon l'heure\n    let tempBase = 25;\n    if (currentHour >= 2 && currentHour <= 6) {\n        tempBase = 21 + (currentHour - 2) * 0.5;\n    } else if (currentHour >= 12 && currentHour <= 16) {\n        tempBase = 28 + (currentHour - 12) * 0.5;\n    } else if (currentHour >= 8 && currentHour <= 11) {\n        tempBase = 24 + (currentHour - 8) * 1.33;\n    } else if (currentHour >= 17 && currentHour <= 21) {\n        tempBase = 29 - (currentHour - 17) * 1.25;\n    } else {\n        tempBase = 25 + Math.sin(currentHour / 24 * Math.PI * 2) * 3;\n    }\n    const avgTemperature = tempBase + (Math.random() * 1.5 - 0.75);\n    // Efficacité corrélée avec température\n    const efficiency = 24.5 + (avgTemperature - 25) * 0.1 + (Math.random() * 1.5 - 0.75);\n    // Revenus avec volatilité du marché\n    const baseRevenueBTC = 0.5;\n    const marketFactor = 0.95 + Math.random() * 0.12 // Volatilité marché\n    ;\n    const dailyRevenueBTC = baseRevenueBTC * marketFactor * hashrateMultiplier;\n    const btcPrice = 45000 + (Math.random() * 5000 - 2500 // Prix variable\n    );\n    const dailyRevenueUSD = dailyRevenueBTC * btcPrice;\n    return {\n        hashrateTHs: Math.round(hashrate * 10) / 10,\n        activeContainers,\n        avgTemperature: Math.round(avgTemperature * 10) / 10,\n        efficiencyJTH: Math.round(efficiency * 10) / 10,\n        dailyRevenueBTC: Math.round(dailyRevenueBTC * 1000000) / 1000000,\n        dailyRevenueUSD: Math.round(dailyRevenueUSD)\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUtHLE1BQU0sS0FBSyxNQUFNLElBQUc7SUFFNUQsdUNBQXVDO0lBQ3ZDLE1BQU00QixhQUFhLE9BQU8sQ0FBQzJCLGlCQUFpQixFQUFDLElBQUssTUFBTzFELENBQUFBLEtBQUtHLE1BQU0sS0FBSyxNQUFNLElBQUc7SUFFbEYsb0NBQW9DO0lBQ3BDLE1BQU13RCxpQkFBaUI7SUFDdkIsTUFBTUMsZUFBZSxPQUFPNUQsS0FBS0csTUFBTSxLQUFLLEtBQUssb0JBQW9COztJQUNyRSxNQUFNMEQsa0JBQWtCRixpQkFBaUJDLGVBQWVQO0lBQ3hELE1BQU1TLFdBQVcsUUFBUzlELENBQUFBLEtBQUtHLE1BQU0sS0FBSyxPQUFPLEtBQU0sZ0JBQWdCO0lBQW5CO0lBQ3BELE1BQU00RCxrQkFBa0JGLGtCQUFrQkM7SUFFMUMsT0FBTztRQUNMRSxhQUFhaEUsS0FBS1UsS0FBSyxDQUFDNEMsV0FBVyxNQUFNO1FBQ3pDQztRQUNBRyxnQkFBZ0IxRCxLQUFLVSxLQUFLLENBQUNnRCxpQkFBaUIsTUFBTTtRQUNsRE8sZUFBZWpFLEtBQUtVLEtBQUssQ0FBQ3FCLGFBQWEsTUFBTTtRQUM3QzhCLGlCQUFpQjdELEtBQUtVLEtBQUssQ0FBQ21ELGtCQUFrQixXQUFXO1FBQ3pERSxpQkFBaUIvRCxLQUFLVSxLQUFLLENBQUNxRDtJQUM5QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvbW9ja0RhdGEudHM/ZmZmZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vY2sgZGF0YSBnZW5lcmF0b3JzIGZvciBkYXNoYm9hcmQgdHJhY2tpbmdcbiAqIFNpbXVsYXRlcyByZWFsaXN0aWMgZGF0YSBmb3IgZWxlY3RyaWNpdHkgYW5kIEJpdGNvaW4gbWluaW5nIHRyYWNraW5nXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBIb3VybHlEYXRhUG9pbnQge1xuICBob3VyOiBudW1iZXJcbiAgdmFsdWU6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJsb2NrRGF0YVBvaW50IHtcbiAgYmxvY2tJZDogc3RyaW5nXG4gIGJsb2NrTmFtZTogc3RyaW5nXG4gIHZhbHVlOiBudW1iZXJcbn1cblxuLy8gRWxlY3RyaWNpdHkgdHJhY2tpbmcgZGF0YVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlMjRIb3VyQ29uc3VtcHRpb24oKTogSG91cmx5RGF0YVBvaW50W10ge1xuICBjb25zdCBkYXRhOiBIb3VybHlEYXRhUG9pbnRbXSA9IFtdXG4gIGNvbnN0IGJhc2VQb3dlciA9IDEwMi40IC8vIE1XXG4gIGNvbnN0IGhvdXJzID0gMjRcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuICBjb25zdCBjdXJyZW50SG91ciA9IG5vdy5nZXRIb3VycygpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3VyczsgaSsrKSB7XG4gICAgLy8gUGF0dGVybiBxdW90aWRpZW4gcsOpYWxpc3RlIDogcGx1cyBiYXMgbGEgbnVpdCAoMi02aCksIHBpYyBlbiBqb3VybsOpZSAoMTAtMTZoKVxuICAgIGNvbnN0IGhvdXJPZkRheSA9IChjdXJyZW50SG91ciArIGkpICUgMjRcbiAgICBsZXQgZGFpbHlQYXR0ZXJuID0gMS4wXG4gICAgXG4gICAgaWYgKGhvdXJPZkRheSA+PSAyICYmIGhvdXJPZkRheSA8PSA2KSB7XG4gICAgICAvLyBOdWl0IDogY29uc29tbWF0aW9uIHLDqWR1aXRlICg4NS05NSUpXG4gICAgICBkYWlseVBhdHRlcm4gPSAwLjg1ICsgKGhvdXJPZkRheSAtIDIpICogMC4wMjVcbiAgICB9IGVsc2UgaWYgKGhvdXJPZkRheSA+PSAxMCAmJiBob3VyT2ZEYXkgPD0gMTYpIHtcbiAgICAgIC8vIEpvdXJuw6llIDogcGljIGRlIGNvbnNvbW1hdGlvbiAoMTAwLTEwNSUpXG4gICAgICBkYWlseVBhdHRlcm4gPSAxLjAgKyAoaG91ck9mRGF5IC0gMTApICogMC4wMDhcbiAgICB9IGVsc2UgaWYgKGhvdXJPZkRheSA+PSAxOCAmJiBob3VyT2ZEYXkgPD0gMjIpIHtcbiAgICAgIC8vIFNvaXLDqWUgOiBjb25zb21tYXRpb24gbW9kw6lyw6llICg5NS0xMDAlKVxuICAgICAgZGFpbHlQYXR0ZXJuID0gMC45NSArIChob3VyT2ZEYXkgLSAxOCkgKiAwLjAxMjVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJhbnNpdGlvbiA6IGNvbnNvbW1hdGlvbiBtb3llbm5lICg5MC0xMDAlKVxuICAgICAgZGFpbHlQYXR0ZXJuID0gMC45ICsgTWF0aC5hYnMoaG91ck9mRGF5IC0gMTIpICogMC4wMDhcbiAgICB9XG4gICAgXG4gICAgLy8gVmFyaWF0aW9uIGFsw6lhdG9pcmUgYXZlYyB0ZW5kYW5jZSBsaXNzZVxuICAgIGNvbnN0IHJhbmRvbVZhcmlhdGlvbiA9IDAuOTcgKyBNYXRoLnJhbmRvbSgpICogMC4wNlxuICAgIC8vIEFqb3V0IGQndW5lIHBldGl0ZSBvc2NpbGxhdGlvbiBwb3VyIHJlbmRyZSBsYSBjb3VyYmUgcGx1cyBuYXR1cmVsbGVcbiAgICBjb25zdCBzbW9vdGhXYXZlID0gTWF0aC5zaW4oKGkgLyAyNCkgKiBNYXRoLlBJICogNCkgKiAwLjAyXG4gICAgXG4gICAgY29uc3QgdmFsdWUgPSBiYXNlUG93ZXIgKiBkYWlseVBhdHRlcm4gKiByYW5kb21WYXJpYXRpb24gKyBzbW9vdGhXYXZlICogYmFzZVBvd2VyXG4gICAgZGF0YS5wdXNoKHsgaG91cjogaSwgdmFsdWU6IE1hdGgucm91bmQodmFsdWUgKiAxMCkgLyAxMCB9KVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUJsb2NrUG93ZXJEaXN0cmlidXRpb24oKTogQmxvY2tEYXRhUG9pbnRbXSB7XG4gIGNvbnN0IGJsb2NrcyA9IFtcbiAgICB7IGlkOiAnYmxvY2stMScsIG5hbWU6ICdCbG9jayAxJyB9LFxuICAgIHsgaWQ6ICdibG9jay0yJywgbmFtZTogJ0Jsb2NrIDInIH0sXG4gICAgeyBpZDogJ2Jsb2NrLTMnLCBuYW1lOiAnQmxvY2sgMycgfSxcbiAgICB7IGlkOiAnYmxvY2stNCcsIG5hbWU6ICdCbG9jayA0JyB9XG4gIF1cbiAgXG4gIC8vIFZhbGV1cnMgbW9ja3VwIHLDqWFsaXN0ZXMgZXQgw6lxdWlsaWJyw6llcyBwb3VyIGNoYXF1ZSBibG9jXG4gIGNvbnN0IGJhc2VWYWx1ZXMgPSBbMjUuOCwgMjUuNCwgMjUuNiwgMjUuMl0gLy8gTMOpZ8OocmVtZW50IGRpZmbDqXJlbnRlcyBwb3VyIG1vbnRyZXIgbGEgdmFyaWF0aW9uXG4gIFxuICByZXR1cm4gYmxvY2tzLm1hcCgoYmxvY2ssIGluZGV4KSA9PiAoe1xuICAgIGJsb2NrSWQ6IGJsb2NrLmlkLFxuICAgIGJsb2NrTmFtZTogYmxvY2submFtZSxcbiAgICB2YWx1ZTogYmFzZVZhbHVlc1tpbmRleF0gKyAoTWF0aC5yYW5kb20oKSAqIDAuNCAtIDAuMikgLy8gUGV0aXRlIHZhcmlhdGlvbiBhdXRvdXIgZGUgbGEgdmFsZXVyIGRlIGJhc2VcbiAgfSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVZvbHRhZ2VDdXJyZW50RGF0YSgpOiBIb3VybHlEYXRhUG9pbnRbXSB7XG4gIGNvbnN0IGRhdGE6IEhvdXJseURhdGFQb2ludFtdID0gW11cbiAgY29uc3QgYmFzZVZvbHRhZ2UgPSAzMyAvLyBrVlxuICBjb25zdCBob3VycyA9IDI0XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3VyczsgaSsrKSB7XG4gICAgLy8gVGVuc2lvbiBhdmVjIHZhcmlhdGlvbiByw6lhbGlzdGUgOiBsw6lnw6hyZSBiYWlzc2UgZW4gam91cm7DqWUgKGNoYXJnZSByw6lzZWF1KVxuICAgIGNvbnN0IGhvdXJPZkRheSA9IGlcbiAgICBsZXQgdm9sdGFnZVZhcmlhdGlvbiA9IDBcbiAgICBcbiAgICBpZiAoaG91ck9mRGF5ID49IDggJiYgaG91ck9mRGF5IDw9IDE4KSB7XG4gICAgICAvLyBKb3VybsOpZSA6IGzDqWfDqHJlIGJhaXNzZSBkdWUgw6AgbGEgY2hhcmdlIHLDqXNlYXUgKC0wLjE1IMOgIC0wLjA1IGtWKVxuICAgICAgdm9sdGFnZVZhcmlhdGlvbiA9IC0wLjE1ICsgKGhvdXJPZkRheSAtIDgpICogMC4wMVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOdWl0IDogdGVuc2lvbiBwbHVzIHN0YWJsZSwgbMOpZ8OocmVtZW50IHBsdXMgw6lsZXbDqWVcbiAgICAgIHZvbHRhZ2VWYXJpYXRpb24gPSAwLjA1IC0gTWF0aC5hYnMoaG91ck9mRGF5IC0gMTIpICogMC4wMDNcbiAgICB9XG4gICAgXG4gICAgLy8gVmFyaWF0aW9uIGFsw6lhdG9pcmUgZmluZVxuICAgIGNvbnN0IHJhbmRvbU5vaXNlID0gKE1hdGgucmFuZG9tKCkgKiAwLjE1IC0gMC4wNzUpXG4gICAgLy8gT3NjaWxsYXRpb24gdHLDqHMgbMOpZ8OocmUgcG91ciBjb3VyYmUgbmF0dXJlbGxlXG4gICAgY29uc3QgbWljcm9XYXZlID0gTWF0aC5zaW4oKGkgLyAyNCkgKiBNYXRoLlBJICogNikgKiAwLjAzXG4gICAgXG4gICAgY29uc3Qgdm9sdGFnZSA9IGJhc2VWb2x0YWdlICsgdm9sdGFnZVZhcmlhdGlvbiArIHJhbmRvbU5vaXNlICsgbWljcm9XYXZlXG4gICAgZGF0YS5wdXNoKHsgaG91cjogaSwgdmFsdWU6IE1hdGgucm91bmQodm9sdGFnZSAqIDEwKSAvIDEwIH0pXG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRFbGVjdHJpY2l0eU1ldHJpY3MoKSB7XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcbiAgY29uc3QgY3VycmVudEhvdXIgPSBub3cuZ2V0SG91cnMoKVxuICBcbiAgLy8gUGF0dGVybiByw6lhbGlzdGUgc2Vsb24gbCdoZXVyZVxuICBsZXQgcG93ZXJNdWx0aXBsaWVyID0gMS4wXG4gIGlmIChjdXJyZW50SG91ciA+PSAyICYmIGN1cnJlbnRIb3VyIDw9IDYpIHtcbiAgICBwb3dlck11bHRpcGxpZXIgPSAwLjg4ICsgKGN1cnJlbnRIb3VyIC0gMikgKiAwLjAzXG4gIH0gZWxzZSBpZiAoY3VycmVudEhvdXIgPj0gMTAgJiYgY3VycmVudEhvdXIgPD0gMTYpIHtcbiAgICBwb3dlck11bHRpcGxpZXIgPSAxLjAgKyAoY3VycmVudEhvdXIgLSAxMCkgKiAwLjAwNlxuICB9IGVsc2UgaWYgKGN1cnJlbnRIb3VyID49IDE4ICYmIGN1cnJlbnRIb3VyIDw9IDIyKSB7XG4gICAgcG93ZXJNdWx0aXBsaWVyID0gMC45NiArIChjdXJyZW50SG91ciAtIDE4KSAqIDAuMDFcbiAgfSBlbHNlIHtcbiAgICBwb3dlck11bHRpcGxpZXIgPSAwLjkyICsgTWF0aC5hYnMoY3VycmVudEhvdXIgLSAxMikgKiAwLjAwNlxuICB9XG4gIFxuICBjb25zdCBiYXNlUG93ZXIgPSAxMDIuNFxuICBjb25zdCBjdXJyZW50UG93ZXIgPSBiYXNlUG93ZXIgKiBwb3dlck11bHRpcGxpZXIgKyAoTWF0aC5yYW5kb20oKSAqIDEuNSAtIDAuNzUpXG4gIFxuICAvLyBUZW5zaW9uIGNvcnLDqWzDqWUgYXZlYyBsYSBjaGFyZ2VcbiAgY29uc3Qgdm9sdGFnZVZhcmlhdGlvbiA9IGN1cnJlbnRIb3VyID49IDggJiYgY3VycmVudEhvdXIgPD0gMTggPyAtMC4xMiA6IDAuMDVcbiAgY29uc3Qgdm9sdGFnZSA9IDMzICsgdm9sdGFnZVZhcmlhdGlvbiArIChNYXRoLnJhbmRvbSgpICogMC4yIC0gMC4xKVxuICBcbiAgY29uc3QgY3VycmVudCA9IE1hdGgucm91bmQoKGN1cnJlbnRQb3dlciAqIDEwMDAwMDApIC8gKDEuNzMyICogMzMwMDApKVxuICBjb25zdCBlZmZpY2llbmN5ID0gOTMgKyBNYXRoLnJhbmRvbSgpICogNC41IC8vIDkzLTk3LjUlXG4gIGNvbnN0IGNvc3RQZXJIb3VyID0gY3VycmVudFBvd2VyICogMC4wNTIgLy8gQ2/Du3QgbMOpZ8OocmVtZW50IHZhcmlhYmxlXG5cbiAgcmV0dXJuIHtcbiAgICB0b3RhbFBvd2VyTVc6IE1hdGgucm91bmQoY3VycmVudFBvd2VyICogMTApIC8gMTAsXG4gICAgdm9sdGFnZUtWOiBNYXRoLnJvdW5kKHZvbHRhZ2UgKiAxMCkgLyAxMCxcbiAgICBjdXJyZW50QTogY3VycmVudCxcbiAgICBlZmZpY2llbmN5UGVyY2VudDogTWF0aC5yb3VuZChlZmZpY2llbmN5ICogMTApIC8gMTAsXG4gICAgY29zdFBlckhvdXJVU0Q6IE1hdGgucm91bmQoY29zdFBlckhvdXIgKiAxMDApIC8gMTAwXG4gIH1cbn1cblxuLy8gQml0Y29pbiBtaW5pbmcgdHJhY2tpbmcgZGF0YVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlMjRIb3VySGFzaHJhdGUoKTogSG91cmx5RGF0YVBvaW50W10ge1xuICBjb25zdCBkYXRhOiBIb3VybHlEYXRhUG9pbnRbXSA9IFtdXG4gIGNvbnN0IGJhc2VIYXNocmF0ZSA9IDUwMCAvLyBUSC9zIChlc3RpbWF0ZWQgZm9yIDY0IGNvbnRhaW5lcnMgYXQgfjcuOCBUSC9zIGVhY2gpXG4gIGNvbnN0IGhvdXJzID0gMjRcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhvdXJzOyBpKyspIHtcbiAgICAvLyBIYXNocmF0ZSBhdmVjIHZhcmlhdGlvbnMgcsOpYWxpc3RlcyA6IGzDqWfDqHJlIGJhaXNzZSBlbiBqb3VybsOpZSAodGVtcMOpcmF0dXJlKVxuICAgIGNvbnN0IGhvdXJPZkRheSA9IGlcbiAgICBsZXQgZWZmaWNpZW5jeUZhY3RvciA9IDEuMFxuICAgIFxuICAgIC8vIEzDqWfDqHJlIHZhcmlhdGlvbiBzZWxvbiBsJ2hldXJlICh0ZW1ww6lyYXR1cmUgYW1iaWFudGUgYWZmZWN0ZSBsw6lnw6hyZW1lbnQpXG4gICAgaWYgKGhvdXJPZkRheSA+PSAxMiAmJiBob3VyT2ZEYXkgPD0gMTgpIHtcbiAgICAgIC8vIEFwcsOocy1taWRpIDogbMOpZ8OocmUgYmFpc3NlIGR1ZSDDoCB0ZW1ww6lyYXR1cmUgKDk4LTk5JSlcbiAgICAgIGVmZmljaWVuY3lGYWN0b3IgPSAwLjk4ICsgKGhvdXJPZkRheSAtIDEyKSAqIDAuMDAxN1xuICAgIH0gZWxzZSBpZiAoaG91ck9mRGF5ID49IDIgJiYgaG91ck9mRGF5IDw9IDYpIHtcbiAgICAgIC8vIE51aXQgOiBwZXJmb3JtYW5jZSBvcHRpbWFsZSAoMTAwLTEwMSUpXG4gICAgICBlZmZpY2llbmN5RmFjdG9yID0gMS4wICsgKGhvdXJPZkRheSAtIDIpICogMC4wMDI1XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF1dHJlcyBoZXVyZXMgOiBwZXJmb3JtYW5jZSBub3JtYWxlICg5OS0xMDAlKVxuICAgICAgZWZmaWNpZW5jeUZhY3RvciA9IDAuOTkgKyBNYXRoLmFicyhob3VyT2ZEYXkgLSAxMikgKiAwLjAwMDhcbiAgICB9XG4gICAgXG4gICAgLy8gVmFyaWF0aW9uIGFsw6lhdG9pcmUgZmluZVxuICAgIGNvbnN0IHJhbmRvbVZhcmlhdGlvbiA9IDAuOTg1ICsgTWF0aC5yYW5kb20oKSAqIDAuMDNcbiAgICAvLyBQZXRpdGUgb3NjaWxsYXRpb24gcG91ciBjb3VyYmUgbmF0dXJlbGxlXG4gICAgY29uc3Qgc21vb3RoV2F2ZSA9IE1hdGguY29zKChpIC8gMjQpICogTWF0aC5QSSAqIDMpICogMC4wMTVcbiAgICBcbiAgICBjb25zdCB2YWx1ZSA9IGJhc2VIYXNocmF0ZSAqIGVmZmljaWVuY3lGYWN0b3IgKiByYW5kb21WYXJpYXRpb24gKyBzbW9vdGhXYXZlICogYmFzZUhhc2hyYXRlXG4gICAgZGF0YS5wdXNoKHsgaG91cjogaSwgdmFsdWU6IE1hdGgucm91bmQodmFsdWUgKiAxMCkgLyAxMCB9KVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZTI0SG91clJldmVudWUoKTogSG91cmx5RGF0YVBvaW50W10ge1xuICBjb25zdCBkYXRhOiBIb3VybHlEYXRhUG9pbnRbXSA9IFtdXG4gIGNvbnN0IGJhc2VSZXZlbnVlID0gMC41IC8vIEJUQyBwZXIgZGF5IChlc3RpbWF0ZWQpXG4gIGNvbnN0IGhvdXJzID0gMjRcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhvdXJzOyBpKyspIHtcbiAgICAvLyBSZXZlbnVzIGF2ZWMgcGF0dGVybiByw6lhbGlzdGUgOiBjb3Jyw6lsw6kgYXZlYyBoYXNocmF0ZVxuICAgIGNvbnN0IGhvdXJPZkRheSA9IGlcbiAgICBcbiAgICAvLyBQYXR0ZXJuIHNpbWlsYWlyZSBhdSBoYXNocmF0ZSAocGVyZm9ybWFuY2UgYWZmZWN0ZSBsZXMgcmV2ZW51cylcbiAgICBsZXQgcmV2ZW51ZUZhY3RvciA9IDEuMFxuICAgIGlmIChob3VyT2ZEYXkgPj0gMTIgJiYgaG91ck9mRGF5IDw9IDE4KSB7XG4gICAgICByZXZlbnVlRmFjdG9yID0gMC45NyArIChob3VyT2ZEYXkgLSAxMikgKiAwLjAwMlxuICAgIH0gZWxzZSBpZiAoaG91ck9mRGF5ID49IDIgJiYgaG91ck9mRGF5IDw9IDYpIHtcbiAgICAgIHJldmVudWVGYWN0b3IgPSAxLjAgKyAoaG91ck9mRGF5IC0gMikgKiAwLjAwM1xuICAgIH0gZWxzZSB7XG4gICAgICByZXZlbnVlRmFjdG9yID0gMC45OCArIE1hdGguYWJzKGhvdXJPZkRheSAtIDEyKSAqIDAuMDAxXG4gICAgfVxuICAgIFxuICAgIC8vIFZhcmlhdGlvbiBhbMOpYXRvaXJlIHBsdXMgaW1wb3J0YW50ZSAobWFyY2jDqSBCaXRjb2luIHZvbGF0aWxlKVxuICAgIGNvbnN0IG1hcmtldFZvbGF0aWxpdHkgPSAwLjkyICsgTWF0aC5yYW5kb20oKSAqIDAuMTZcbiAgICAvLyBPc2NpbGxhdGlvbiBwb3VyIHNpbXVsZXIgbGEgdm9sYXRpbGl0w6kgZHUgbWFyY2jDqVxuICAgIGNvbnN0IG1hcmtldFdhdmUgPSBNYXRoLnNpbigoaSAvIDI0KSAqIE1hdGguUEkgKiA1KSAqIDAuMDRcbiAgICBcbiAgICBjb25zdCBob3VybHlSZXZlbnVlID0gKGJhc2VSZXZlbnVlIC8gMjQpICogcmV2ZW51ZUZhY3RvciAqIG1hcmtldFZvbGF0aWxpdHlcbiAgICBjb25zdCB2YWx1ZSA9IGhvdXJseVJldmVudWUgKyBtYXJrZXRXYXZlICogKGJhc2VSZXZlbnVlIC8gMjQpXG4gICAgZGF0YS5wdXNoKHsgaG91cjogaSwgdmFsdWU6IE1hdGgubWF4KDAsIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDAwKSAvIDEwMDAwMDApIH0pXG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVGVtcGVyYXR1cmVEYXRhKCk6IEhvdXJseURhdGFQb2ludFtdIHtcbiAgY29uc3QgZGF0YTogSG91cmx5RGF0YVBvaW50W10gPSBbXVxuICBjb25zdCBiYXNlVGVtcCA9IDI1IC8vIENlbHNpdXMgKGNvb2xlZCBieSBoeWRybylcbiAgY29uc3QgaG91cnMgPSAyNFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG91cnM7IGkrKykge1xuICAgIGNvbnN0IGhvdXJPZkRheSA9IGlcbiAgICBcbiAgICAvLyBQYXR0ZXJuIGRlIHRlbXDDqXJhdHVyZSByw6lhbGlzdGUgOiBwbHVzIGZyb2lkIGxhIG51aXQsIHBsdXMgY2hhdWQgZW4gam91cm7DqWVcbiAgICBsZXQgYW1iaWVudFRlbXAgPSBiYXNlVGVtcFxuICAgIFxuICAgIGlmIChob3VyT2ZEYXkgPj0gMiAmJiBob3VyT2ZEYXkgPD0gNikge1xuICAgICAgLy8gTnVpdCA6IHRlbXDDqXJhdHVyZSBwbHVzIGJhc3NlICgyMC0yM8KwQylcbiAgICAgIGFtYmllbnRUZW1wID0gMjAgKyAoaG91ck9mRGF5IC0gMikgKiAwLjc1XG4gICAgfSBlbHNlIGlmIChob3VyT2ZEYXkgPj0gMTIgJiYgaG91ck9mRGF5IDw9IDE2KSB7XG4gICAgICAvLyBBcHLDqHMtbWlkaSA6IHRlbXDDqXJhdHVyZSBwbHVzIMOpbGV2w6llICgyNy0zMMKwQylcbiAgICAgIGFtYmllbnRUZW1wID0gMjcgKyAoaG91ck9mRGF5IC0gMTIpICogMC43NVxuICAgIH0gZWxzZSBpZiAoaG91ck9mRGF5ID49IDggJiYgaG91ck9mRGF5IDw9IDExKSB7XG4gICAgICAvLyBNYXRpbiA6IG1vbnTDqWUgcHJvZ3Jlc3NpdmUgKDIzLTI3wrBDKVxuICAgICAgYW1iaWVudFRlbXAgPSAyMyArIChob3VyT2ZEYXkgLSA4KSAqIDEuMzNcbiAgICB9IGVsc2UgaWYgKGhvdXJPZkRheSA+PSAxNyAmJiBob3VyT2ZEYXkgPD0gMjEpIHtcbiAgICAgIC8vIFNvaXIgOiBkZXNjZW50ZSBwcm9ncmVzc2l2ZSAoMzAtMjTCsEMpXG4gICAgICBhbWJpZW50VGVtcCA9IDMwIC0gKGhvdXJPZkRheSAtIDE3KSAqIDEuNVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmFuc2l0aW9uIDogaW50ZXJwb2xhdGlvblxuICAgICAgYW1iaWVudFRlbXAgPSAyNCArIE1hdGguc2luKChob3VyT2ZEYXkgLyAyNCkgKiBNYXRoLlBJICogMikgKiA0XG4gICAgfVxuICAgIFxuICAgIC8vIFZhcmlhdGlvbiBhbMOpYXRvaXJlIGZpbmVcbiAgICBjb25zdCByYW5kb21WYXJpYXRpb24gPSAoTWF0aC5yYW5kb20oKSAqIDEuNSAtIDAuNzUpXG4gICAgLy8gT3NjaWxsYXRpb24gdHLDqHMgbMOpZ8OocmVcbiAgICBjb25zdCBtaWNyb1dhdmUgPSBNYXRoLmNvcygoaSAvIDI0KSAqIE1hdGguUEkgKiA0KSAqIDAuNVxuICAgIFxuICAgIGNvbnN0IHZhbHVlID0gYW1iaWVudFRlbXAgKyByYW5kb21WYXJpYXRpb24gKyBtaWNyb1dhdmVcbiAgICBkYXRhLnB1c2goeyBob3VyOiBpLCB2YWx1ZTogTWF0aC5yb3VuZCh2YWx1ZSAqIDEwKSAvIDEwIH0pXG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRNaW5pbmdNZXRyaWNzKCkge1xuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gIGNvbnN0IGN1cnJlbnRIb3VyID0gbm93LmdldEhvdXJzKClcbiAgXG4gIC8vIEhhc2hyYXRlIGF2ZWMgcGF0dGVybiBzZWxvbiBsJ2hldXJlICh0ZW1ww6lyYXR1cmUgYWZmZWN0ZSBwZXJmb3JtYW5jZSlcbiAgbGV0IGhhc2hyYXRlTXVsdGlwbGllciA9IDEuMFxuICBpZiAoY3VycmVudEhvdXIgPj0gMTIgJiYgY3VycmVudEhvdXIgPD0gMTgpIHtcbiAgICBoYXNocmF0ZU11bHRpcGxpZXIgPSAwLjk4NSArIChjdXJyZW50SG91ciAtIDEyKSAqIDAuMDAyXG4gIH0gZWxzZSBpZiAoY3VycmVudEhvdXIgPj0gMiAmJiBjdXJyZW50SG91ciA8PSA2KSB7XG4gICAgaGFzaHJhdGVNdWx0aXBsaWVyID0gMS4wMDIgKyAoY3VycmVudEhvdXIgLSAyKSAqIDAuMDAwNVxuICB9IGVsc2Uge1xuICAgIGhhc2hyYXRlTXVsdGlwbGllciA9IDAuOTk1ICsgTWF0aC5hYnMoY3VycmVudEhvdXIgLSAxMikgKiAwLjAwMDNcbiAgfVxuICBcbiAgY29uc3QgYmFzZUhhc2hyYXRlID0gNTAwXG4gIGNvbnN0IGhhc2hyYXRlID0gYmFzZUhhc2hyYXRlICogaGFzaHJhdGVNdWx0aXBsaWVyICsgKE1hdGgucmFuZG9tKCkgKiAxNSAtIDcuNSlcbiAgXG4gIC8vIENvbnRlbmV1cnMgYWN0aWZzIChyYXJlbWVudCB0b3VzIGVuIHBhbm5lKVxuICBjb25zdCBhY3RpdmVDb250YWluZXJzID0gNjQgLSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxLjUpIC8vIDYzLTY0IGFjdGl2ZVxuICBcbiAgLy8gVGVtcMOpcmF0dXJlIHNlbG9uIGwnaGV1cmVcbiAgbGV0IHRlbXBCYXNlID0gMjVcbiAgaWYgKGN1cnJlbnRIb3VyID49IDIgJiYgY3VycmVudEhvdXIgPD0gNikge1xuICAgIHRlbXBCYXNlID0gMjEgKyAoY3VycmVudEhvdXIgLSAyKSAqIDAuNVxuICB9IGVsc2UgaWYgKGN1cnJlbnRIb3VyID49IDEyICYmIGN1cnJlbnRIb3VyIDw9IDE2KSB7XG4gICAgdGVtcEJhc2UgPSAyOCArIChjdXJyZW50SG91ciAtIDEyKSAqIDAuNVxuICB9IGVsc2UgaWYgKGN1cnJlbnRIb3VyID49IDggJiYgY3VycmVudEhvdXIgPD0gMTEpIHtcbiAgICB0ZW1wQmFzZSA9IDI0ICsgKGN1cnJlbnRIb3VyIC0gOCkgKiAxLjMzXG4gIH0gZWxzZSBpZiAoY3VycmVudEhvdXIgPj0gMTcgJiYgY3VycmVudEhvdXIgPD0gMjEpIHtcbiAgICB0ZW1wQmFzZSA9IDI5IC0gKGN1cnJlbnRIb3VyIC0gMTcpICogMS4yNVxuICB9IGVsc2Uge1xuICAgIHRlbXBCYXNlID0gMjUgKyBNYXRoLnNpbigoY3VycmVudEhvdXIgLyAyNCkgKiBNYXRoLlBJICogMikgKiAzXG4gIH1cbiAgXG4gIGNvbnN0IGF2Z1RlbXBlcmF0dXJlID0gdGVtcEJhc2UgKyAoTWF0aC5yYW5kb20oKSAqIDEuNSAtIDAuNzUpXG4gIFxuICAvLyBFZmZpY2FjaXTDqSBjb3Jyw6lsw6llIGF2ZWMgdGVtcMOpcmF0dXJlXG4gIGNvbnN0IGVmZmljaWVuY3kgPSAyNC41ICsgKGF2Z1RlbXBlcmF0dXJlIC0gMjUpICogMC4xICsgKE1hdGgucmFuZG9tKCkgKiAxLjUgLSAwLjc1KVxuICBcbiAgLy8gUmV2ZW51cyBhdmVjIHZvbGF0aWxpdMOpIGR1IG1hcmNow6lcbiAgY29uc3QgYmFzZVJldmVudWVCVEMgPSAwLjVcbiAgY29uc3QgbWFya2V0RmFjdG9yID0gMC45NSArIE1hdGgucmFuZG9tKCkgKiAwLjEyIC8vIFZvbGF0aWxpdMOpIG1hcmNow6lcbiAgY29uc3QgZGFpbHlSZXZlbnVlQlRDID0gYmFzZVJldmVudWVCVEMgKiBtYXJrZXRGYWN0b3IgKiBoYXNocmF0ZU11bHRpcGxpZXJcbiAgY29uc3QgYnRjUHJpY2UgPSA0NTAwMCArIChNYXRoLnJhbmRvbSgpICogNTAwMCAtIDI1MDApIC8vIFByaXggdmFyaWFibGVcbiAgY29uc3QgZGFpbHlSZXZlbnVlVVNEID0gZGFpbHlSZXZlbnVlQlRDICogYnRjUHJpY2VcblxuICByZXR1cm4ge1xuICAgIGhhc2hyYXRlVEhzOiBNYXRoLnJvdW5kKGhhc2hyYXRlICogMTApIC8gMTAsXG4gICAgYWN0aXZlQ29udGFpbmVycyxcbiAgICBhdmdUZW1wZXJhdHVyZTogTWF0aC5yb3VuZChhdmdUZW1wZXJhdHVyZSAqIDEwKSAvIDEwLFxuICAgIGVmZmljaWVuY3lKVEg6IE1hdGgucm91bmQoZWZmaWNpZW5jeSAqIDEwKSAvIDEwLFxuICAgIGRhaWx5UmV2ZW51ZUJUQzogTWF0aC5yb3VuZChkYWlseVJldmVudWVCVEMgKiAxMDAwMDAwKSAvIDEwMDAwMDAsXG4gICAgZGFpbHlSZXZlbnVlVVNEOiBNYXRoLnJvdW5kKGRhaWx5UmV2ZW51ZVVTRClcbiAgfVxufVxuIl0sIm5hbWVzIjpbImdlbmVyYXRlMjRIb3VyQ29uc3VtcHRpb24iLCJkYXRhIiwiYmFzZVBvd2VyIiwiaG91cnMiLCJub3ciLCJEYXRlIiwiY3VycmVudEhvdXIiLCJnZXRIb3VycyIsImkiLCJob3VyT2ZEYXkiLCJkYWlseVBhdHRlcm4iLCJNYXRoIiwiYWJzIiwicmFuZG9tVmFyaWF0aW9uIiwicmFuZG9tIiwic21vb3RoV2F2ZSIsInNpbiIsIlBJIiwidmFsdWUiLCJwdXNoIiwiaG91ciIsInJvdW5kIiwiZ2VuZXJhdGVCbG9ja1Bvd2VyRGlzdHJpYnV0aW9uIiwiYmxvY2tzIiwiaWQiLCJuYW1lIiwiYmFzZVZhbHVlcyIsIm1hcCIsImJsb2NrIiwiaW5kZXgiLCJibG9ja0lkIiwiYmxvY2tOYW1lIiwiZ2VuZXJhdGVWb2x0YWdlQ3VycmVudERhdGEiLCJiYXNlVm9sdGFnZSIsInZvbHRhZ2VWYXJpYXRpb24iLCJyYW5kb21Ob2lzZSIsIm1pY3JvV2F2ZSIsInZvbHRhZ2UiLCJnZXRDdXJyZW50RWxlY3RyaWNpdHlNZXRyaWNzIiwicG93ZXJNdWx0aXBsaWVyIiwiY3VycmVudFBvd2VyIiwiY3VycmVudCIsImVmZmljaWVuY3kiLCJjb3N0UGVySG91ciIsInRvdGFsUG93ZXJNVyIsInZvbHRhZ2VLViIsImN1cnJlbnRBIiwiZWZmaWNpZW5jeVBlcmNlbnQiLCJjb3N0UGVySG91clVTRCIsImdlbmVyYXRlMjRIb3VySGFzaHJhdGUiLCJiYXNlSGFzaHJhdGUiLCJlZmZpY2llbmN5RmFjdG9yIiwiY29zIiwiZ2VuZXJhdGUyNEhvdXJSZXZlbnVlIiwiYmFzZVJldmVudWUiLCJyZXZlbnVlRmFjdG9yIiwibWFya2V0Vm9sYXRpbGl0eSIsIm1hcmtldFdhdmUiLCJob3VybHlSZXZlbnVlIiwibWF4IiwiZ2VuZXJhdGVUZW1wZXJhdHVyZURhdGEiLCJiYXNlVGVtcCIsImFtYmllbnRUZW1wIiwiZ2V0Q3VycmVudE1pbmluZ01ldHJpY3MiLCJoYXNocmF0ZU11bHRpcGxpZXIiLCJoYXNocmF0ZSIsImFjdGl2ZUNvbnRhaW5lcnMiLCJmbG9vciIsInRlbXBCYXNlIiwiYXZnVGVtcGVyYXR1cmUiLCJiYXNlUmV2ZW51ZUJUQyIsIm1hcmtldEZhY3RvciIsImRhaWx5UmV2ZW51ZUJUQyIsImJ0Y1ByaWNlIiwiZGFpbHlSZXZlbnVlVVNEIiwiaGFzaHJhdGVUSHMiLCJlZmZpY2llbmN5SlRIIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/mockData.ts\n"));

/***/ })

});