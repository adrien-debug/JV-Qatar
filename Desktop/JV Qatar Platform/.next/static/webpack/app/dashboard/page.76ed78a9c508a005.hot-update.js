"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/mockData.ts":
/*!*****************************!*\
  !*** ./src/lib/mockData.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generate24HourConsumption: function() { return /* binding */ generate24HourConsumption; },\n/* harmony export */   generate24HourHashrate: function() { return /* binding */ generate24HourHashrate; },\n/* harmony export */   generate24HourRevenue: function() { return /* binding */ generate24HourRevenue; },\n/* harmony export */   generateBlockPowerDistribution: function() { return /* binding */ generateBlockPowerDistribution; },\n/* harmony export */   generateTemperatureData: function() { return /* binding */ generateTemperatureData; },\n/* harmony export */   generateVoltageCurrentData: function() { return /* binding */ generateVoltageCurrentData; },\n/* harmony export */   getCurrentElectricityMetrics: function() { return /* binding */ getCurrentElectricityMetrics; },\n/* harmony export */   getCurrentMiningMetrics: function() { return /* binding */ getCurrentMiningMetrics; }\n/* harmony export */ });\n/**\n * Mock data generators for dashboard tracking\n * Simulates realistic data for electricity and Bitcoin mining tracking\n */ // Electricity tracking data\nfunction generate24HourConsumption() {\n    const data = [];\n    const basePower = 102.4 // MW\n    ;\n    const hours = 24;\n    const now = new Date();\n    const currentHour = now.getHours();\n    for(let i = 0; i < hours; i++){\n        // Pattern quotidien réaliste : plus bas la nuit (2-6h), pic en journée (10-16h)\n        const hourOfDay = (currentHour + i) % 24;\n        let dailyPattern = 1.0;\n        if (hourOfDay >= 2 && hourOfDay <= 6) {\n            // Nuit : consommation réduite (85-95%)\n            dailyPattern = 0.85 + (hourOfDay - 2) * 0.025;\n        } else if (hourOfDay >= 10 && hourOfDay <= 16) {\n            // Journée : pic de consommation (100-105%)\n            dailyPattern = 1.0 + (hourOfDay - 10) * 0.008;\n        } else if (hourOfDay >= 18 && hourOfDay <= 22) {\n            // Soirée : consommation modérée (95-100%)\n            dailyPattern = 0.95 + (hourOfDay - 18) * 0.0125;\n        } else {\n            // Transition : consommation moyenne (90-100%)\n            dailyPattern = 0.9 + Math.abs(hourOfDay - 12) * 0.008;\n        }\n        // Variation aléatoire avec tendance lisse\n        const randomVariation = 0.97 + Math.random() * 0.06;\n        // Ajout d'une petite oscillation pour rendre la courbe plus naturelle\n        const smoothWave = Math.sin(i / 24 * Math.PI * 4) * 0.02;\n        const value = basePower * dailyPattern * randomVariation + smoothWave * basePower;\n        data.push({\n            hour: i,\n            value: Math.round(value * 10) / 10\n        });\n    }\n    return data;\n}\nfunction generateBlockPowerDistribution() {\n    const blocks = [\n        {\n            id: \"block-1\",\n            name: \"Block 1\"\n        },\n        {\n            id: \"block-2\",\n            name: \"Block 2\"\n        },\n        {\n            id: \"block-3\",\n            name: \"Block 3\"\n        },\n        {\n            id: \"block-4\",\n            name: \"Block 4\"\n        }\n    ];\n    // Valeurs mockup réalistes et équilibrées pour chaque bloc\n    const baseValues = [\n        25.8,\n        25.4,\n        25.6,\n        25.2\n    ] // Légèrement différentes pour montrer la variation\n    ;\n    return blocks.map((block, index)=>({\n            blockId: block.id,\n            blockName: block.name,\n            value: baseValues[index] + (Math.random() * 0.4 - 0.2 // Petite variation autour de la valeur de base\n            )\n        }));\n}\nfunction generateVoltageCurrentData() {\n    const data = [];\n    const baseVoltage = 33 // kV\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        // Tension avec variation réaliste : légère baisse en journée (charge réseau)\n        const hourOfDay = i;\n        let voltageVariation = 0;\n        if (hourOfDay >= 8 && hourOfDay <= 18) {\n            // Journée : légère baisse due à la charge réseau (-0.15 à -0.05 kV)\n            voltageVariation = -0.15 + (hourOfDay - 8) * 0.01;\n        } else {\n            // Nuit : tension plus stable, légèrement plus élevée\n            voltageVariation = 0.05 - Math.abs(hourOfDay - 12) * 0.003;\n        }\n        // Variation aléatoire fine\n        const randomNoise = Math.random() * 0.15 - 0.075;\n        // Oscillation très légère pour courbe naturelle\n        const microWave = Math.sin(i / 24 * Math.PI * 6) * 0.03;\n        const voltage = baseVoltage + voltageVariation + randomNoise + microWave;\n        data.push({\n            hour: i,\n            value: Math.round(voltage * 10) / 10\n        });\n    }\n    return data;\n}\nfunction getCurrentElectricityMetrics() {\n    const currentPower = 102.4 + (Math.random() * 2 - 1);\n    const voltage = 33 + (Math.random() * 0.4 - 0.2);\n    const current = Math.round(currentPower * 1000000 / (1.732 * 33000));\n    const efficiency = 92 + Math.random() * 5 // 92-97%\n    ;\n    const costPerHour = currentPower * 0.05 // Assuming ~0.05 USD/kWh\n    ;\n    return {\n        totalPowerMW: Math.round(currentPower * 10) / 10,\n        voltageKV: Math.round(voltage * 10) / 10,\n        currentA: current,\n        efficiencyPercent: Math.round(efficiency * 10) / 10,\n        costPerHourUSD: Math.round(costPerHour * 100) / 100\n    };\n}\n// Bitcoin mining tracking data\nfunction generate24HourHashrate() {\n    const data = [];\n    const baseHashrate = 500 // TH/s (estimated for 64 containers at ~7.8 TH/s each)\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        // Hashrate avec variations réalistes : légère baisse en journée (température)\n        const hourOfDay = i;\n        let efficiencyFactor = 1.0;\n        // Légère variation selon l'heure (température ambiante affecte légèrement)\n        if (hourOfDay >= 12 && hourOfDay <= 18) {\n            // Après-midi : légère baisse due à température (98-99%)\n            efficiencyFactor = 0.98 + (hourOfDay - 12) * 0.0017;\n        } else if (hourOfDay >= 2 && hourOfDay <= 6) {\n            // Nuit : performance optimale (100-101%)\n            efficiencyFactor = 1.0 + (hourOfDay - 2) * 0.0025;\n        } else {\n            // Autres heures : performance normale (99-100%)\n            efficiencyFactor = 0.99 + Math.abs(hourOfDay - 12) * 0.0008;\n        }\n        // Variation aléatoire fine\n        const randomVariation = 0.985 + Math.random() * 0.03;\n        // Petite oscillation pour courbe naturelle\n        const smoothWave = Math.cos(i / 24 * Math.PI * 3) * 0.015;\n        const value = baseHashrate * efficiencyFactor * randomVariation + smoothWave * baseHashrate;\n        data.push({\n            hour: i,\n            value: Math.round(value * 10) / 10\n        });\n    }\n    return data;\n}\nfunction generate24HourRevenue() {\n    const data = [];\n    const baseRevenue = 0.5 // BTC per day (estimated)\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        // Revenue varies slightly\n        const variation = 0.95 + Math.random() * 0.1;\n        const value = baseRevenue / 24 * variation;\n        data.push({\n            hour: i,\n            value: Math.round(value * 1000000) / 1000000\n        });\n    }\n    return data;\n}\nfunction generateTemperatureData() {\n    const data = [];\n    const baseTemp = 25 // Celsius (cooled by hydro)\n    ;\n    const hours = 24;\n    for(let i = 0; i < hours; i++){\n        // Temperature varies with ambient (20-30°C)\n        const ambientVariation = Math.sin(i / 24 * Math.PI * 2) * 5;\n        const value = baseTemp + ambientVariation + (Math.random() * 2 - 1);\n        data.push({\n            hour: i,\n            value: Math.round(value * 10) / 10\n        });\n    }\n    return data;\n}\nfunction getCurrentMiningMetrics() {\n    const hashrate = 500 + (Math.random() * 20 - 10 // TH/s\n    );\n    const activeContainers = 64 - Math.floor(Math.random() * 2) // 63-64 active\n    ;\n    const avgTemperature = 25 + (Math.random() * 5 - 2.5 // 22.5-27.5°C\n    );\n    const efficiency = 25 + Math.random() * 2 // J/TH (joules per terahash)\n    ;\n    const dailyRevenueBTC = 0.5 + (Math.random() * 0.1 - 0.05);\n    const btcPrice = 45000 // USD (example)\n    ;\n    const dailyRevenueUSD = dailyRevenueBTC * btcPrice;\n    return {\n        hashrateTHs: Math.round(hashrate * 10) / 10,\n        activeContainers,\n        avgTemperature: Math.round(avgTemperature * 10) / 10,\n        efficiencyJTH: Math.round(efficiency * 10) / 10,\n        dailyRevenueBTC: Math.round(dailyRevenueBTC * 1000000) / 1000000,\n        dailyRevenueUSD: Math.round(dailyRevenueUSD)\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ekRFLGlCQUFpQnRELEtBQUtVLEtBQUssQ0FBQzRDO0lBQzlCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9tb2NrRGF0YS50cz9mZmZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9jayBkYXRhIGdlbmVyYXRvcnMgZm9yIGRhc2hib2FyZCB0cmFja2luZ1xuICogU2ltdWxhdGVzIHJlYWxpc3RpYyBkYXRhIGZvciBlbGVjdHJpY2l0eSBhbmQgQml0Y29pbiBtaW5pbmcgdHJhY2tpbmdcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIEhvdXJseURhdGFQb2ludCB7XG4gIGhvdXI6IG51bWJlclxuICB2YWx1ZTogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmxvY2tEYXRhUG9pbnQge1xuICBibG9ja0lkOiBzdHJpbmdcbiAgYmxvY2tOYW1lOiBzdHJpbmdcbiAgdmFsdWU6IG51bWJlclxufVxuXG4vLyBFbGVjdHJpY2l0eSB0cmFja2luZyBkYXRhXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGUyNEhvdXJDb25zdW1wdGlvbigpOiBIb3VybHlEYXRhUG9pbnRbXSB7XG4gIGNvbnN0IGRhdGE6IEhvdXJseURhdGFQb2ludFtdID0gW11cbiAgY29uc3QgYmFzZVBvd2VyID0gMTAyLjQgLy8gTVdcbiAgY29uc3QgaG91cnMgPSAyNFxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gIGNvbnN0IGN1cnJlbnRIb3VyID0gbm93LmdldEhvdXJzKClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhvdXJzOyBpKyspIHtcbiAgICAvLyBQYXR0ZXJuIHF1b3RpZGllbiByw6lhbGlzdGUgOiBwbHVzIGJhcyBsYSBudWl0ICgyLTZoKSwgcGljIGVuIGpvdXJuw6llICgxMC0xNmgpXG4gICAgY29uc3QgaG91ck9mRGF5ID0gKGN1cnJlbnRIb3VyICsgaSkgJSAyNFxuICAgIGxldCBkYWlseVBhdHRlcm4gPSAxLjBcbiAgICBcbiAgICBpZiAoaG91ck9mRGF5ID49IDIgJiYgaG91ck9mRGF5IDw9IDYpIHtcbiAgICAgIC8vIE51aXQgOiBjb25zb21tYXRpb24gcsOpZHVpdGUgKDg1LTk1JSlcbiAgICAgIGRhaWx5UGF0dGVybiA9IDAuODUgKyAoaG91ck9mRGF5IC0gMikgKiAwLjAyNVxuICAgIH0gZWxzZSBpZiAoaG91ck9mRGF5ID49IDEwICYmIGhvdXJPZkRheSA8PSAxNikge1xuICAgICAgLy8gSm91cm7DqWUgOiBwaWMgZGUgY29uc29tbWF0aW9uICgxMDAtMTA1JSlcbiAgICAgIGRhaWx5UGF0dGVybiA9IDEuMCArIChob3VyT2ZEYXkgLSAxMCkgKiAwLjAwOFxuICAgIH0gZWxzZSBpZiAoaG91ck9mRGF5ID49IDE4ICYmIGhvdXJPZkRheSA8PSAyMikge1xuICAgICAgLy8gU29pcsOpZSA6IGNvbnNvbW1hdGlvbiBtb2TDqXLDqWUgKDk1LTEwMCUpXG4gICAgICBkYWlseVBhdHRlcm4gPSAwLjk1ICsgKGhvdXJPZkRheSAtIDE4KSAqIDAuMDEyNVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmFuc2l0aW9uIDogY29uc29tbWF0aW9uIG1veWVubmUgKDkwLTEwMCUpXG4gICAgICBkYWlseVBhdHRlcm4gPSAwLjkgKyBNYXRoLmFicyhob3VyT2ZEYXkgLSAxMikgKiAwLjAwOFxuICAgIH1cbiAgICBcbiAgICAvLyBWYXJpYXRpb24gYWzDqWF0b2lyZSBhdmVjIHRlbmRhbmNlIGxpc3NlXG4gICAgY29uc3QgcmFuZG9tVmFyaWF0aW9uID0gMC45NyArIE1hdGgucmFuZG9tKCkgKiAwLjA2XG4gICAgLy8gQWpvdXQgZCd1bmUgcGV0aXRlIG9zY2lsbGF0aW9uIHBvdXIgcmVuZHJlIGxhIGNvdXJiZSBwbHVzIG5hdHVyZWxsZVxuICAgIGNvbnN0IHNtb290aFdhdmUgPSBNYXRoLnNpbigoaSAvIDI0KSAqIE1hdGguUEkgKiA0KSAqIDAuMDJcbiAgICBcbiAgICBjb25zdCB2YWx1ZSA9IGJhc2VQb3dlciAqIGRhaWx5UGF0dGVybiAqIHJhbmRvbVZhcmlhdGlvbiArIHNtb290aFdhdmUgKiBiYXNlUG93ZXJcbiAgICBkYXRhLnB1c2goeyBob3VyOiBpLCB2YWx1ZTogTWF0aC5yb3VuZCh2YWx1ZSAqIDEwKSAvIDEwIH0pXG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQmxvY2tQb3dlckRpc3RyaWJ1dGlvbigpOiBCbG9ja0RhdGFQb2ludFtdIHtcbiAgY29uc3QgYmxvY2tzID0gW1xuICAgIHsgaWQ6ICdibG9jay0xJywgbmFtZTogJ0Jsb2NrIDEnIH0sXG4gICAgeyBpZDogJ2Jsb2NrLTInLCBuYW1lOiAnQmxvY2sgMicgfSxcbiAgICB7IGlkOiAnYmxvY2stMycsIG5hbWU6ICdCbG9jayAzJyB9LFxuICAgIHsgaWQ6ICdibG9jay00JywgbmFtZTogJ0Jsb2NrIDQnIH1cbiAgXVxuICBcbiAgLy8gVmFsZXVycyBtb2NrdXAgcsOpYWxpc3RlcyBldCDDqXF1aWxpYnLDqWVzIHBvdXIgY2hhcXVlIGJsb2NcbiAgY29uc3QgYmFzZVZhbHVlcyA9IFsyNS44LCAyNS40LCAyNS42LCAyNS4yXSAvLyBMw6lnw6hyZW1lbnQgZGlmZsOpcmVudGVzIHBvdXIgbW9udHJlciBsYSB2YXJpYXRpb25cbiAgXG4gIHJldHVybiBibG9ja3MubWFwKChibG9jaywgaW5kZXgpID0+ICh7XG4gICAgYmxvY2tJZDogYmxvY2suaWQsXG4gICAgYmxvY2tOYW1lOiBibG9jay5uYW1lLFxuICAgIHZhbHVlOiBiYXNlVmFsdWVzW2luZGV4XSArIChNYXRoLnJhbmRvbSgpICogMC40IC0gMC4yKSAvLyBQZXRpdGUgdmFyaWF0aW9uIGF1dG91ciBkZSBsYSB2YWxldXIgZGUgYmFzZVxuICB9KSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVm9sdGFnZUN1cnJlbnREYXRhKCk6IEhvdXJseURhdGFQb2ludFtdIHtcbiAgY29uc3QgZGF0YTogSG91cmx5RGF0YVBvaW50W10gPSBbXVxuICBjb25zdCBiYXNlVm9sdGFnZSA9IDMzIC8vIGtWXG4gIGNvbnN0IGhvdXJzID0gMjRcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhvdXJzOyBpKyspIHtcbiAgICAvLyBUZW5zaW9uIGF2ZWMgdmFyaWF0aW9uIHLDqWFsaXN0ZSA6IGzDqWfDqHJlIGJhaXNzZSBlbiBqb3VybsOpZSAoY2hhcmdlIHLDqXNlYXUpXG4gICAgY29uc3QgaG91ck9mRGF5ID0gaVxuICAgIGxldCB2b2x0YWdlVmFyaWF0aW9uID0gMFxuICAgIFxuICAgIGlmIChob3VyT2ZEYXkgPj0gOCAmJiBob3VyT2ZEYXkgPD0gMTgpIHtcbiAgICAgIC8vIEpvdXJuw6llIDogbMOpZ8OocmUgYmFpc3NlIGR1ZSDDoCBsYSBjaGFyZ2UgcsOpc2VhdSAoLTAuMTUgw6AgLTAuMDUga1YpXG4gICAgICB2b2x0YWdlVmFyaWF0aW9uID0gLTAuMTUgKyAoaG91ck9mRGF5IC0gOCkgKiAwLjAxXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE51aXQgOiB0ZW5zaW9uIHBsdXMgc3RhYmxlLCBsw6lnw6hyZW1lbnQgcGx1cyDDqWxldsOpZVxuICAgICAgdm9sdGFnZVZhcmlhdGlvbiA9IDAuMDUgLSBNYXRoLmFicyhob3VyT2ZEYXkgLSAxMikgKiAwLjAwM1xuICAgIH1cbiAgICBcbiAgICAvLyBWYXJpYXRpb24gYWzDqWF0b2lyZSBmaW5lXG4gICAgY29uc3QgcmFuZG9tTm9pc2UgPSAoTWF0aC5yYW5kb20oKSAqIDAuMTUgLSAwLjA3NSlcbiAgICAvLyBPc2NpbGxhdGlvbiB0csOocyBsw6lnw6hyZSBwb3VyIGNvdXJiZSBuYXR1cmVsbGVcbiAgICBjb25zdCBtaWNyb1dhdmUgPSBNYXRoLnNpbigoaSAvIDI0KSAqIE1hdGguUEkgKiA2KSAqIDAuMDNcbiAgICBcbiAgICBjb25zdCB2b2x0YWdlID0gYmFzZVZvbHRhZ2UgKyB2b2x0YWdlVmFyaWF0aW9uICsgcmFuZG9tTm9pc2UgKyBtaWNyb1dhdmVcbiAgICBkYXRhLnB1c2goeyBob3VyOiBpLCB2YWx1ZTogTWF0aC5yb3VuZCh2b2x0YWdlICogMTApIC8gMTAgfSlcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudEVsZWN0cmljaXR5TWV0cmljcygpIHtcbiAgY29uc3QgY3VycmVudFBvd2VyID0gMTAyLjQgKyAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKVxuICBjb25zdCB2b2x0YWdlID0gMzMgKyAoTWF0aC5yYW5kb20oKSAqIDAuNCAtIDAuMilcbiAgY29uc3QgY3VycmVudCA9IE1hdGgucm91bmQoKGN1cnJlbnRQb3dlciAqIDEwMDAwMDApIC8gKDEuNzMyICogMzMwMDApKVxuICBjb25zdCBlZmZpY2llbmN5ID0gOTIgKyBNYXRoLnJhbmRvbSgpICogNSAvLyA5Mi05NyVcbiAgY29uc3QgY29zdFBlckhvdXIgPSBjdXJyZW50UG93ZXIgKiAwLjA1IC8vIEFzc3VtaW5nIH4wLjA1IFVTRC9rV2hcblxuICByZXR1cm4ge1xuICAgIHRvdGFsUG93ZXJNVzogTWF0aC5yb3VuZChjdXJyZW50UG93ZXIgKiAxMCkgLyAxMCxcbiAgICB2b2x0YWdlS1Y6IE1hdGgucm91bmQodm9sdGFnZSAqIDEwKSAvIDEwLFxuICAgIGN1cnJlbnRBOiBjdXJyZW50LFxuICAgIGVmZmljaWVuY3lQZXJjZW50OiBNYXRoLnJvdW5kKGVmZmljaWVuY3kgKiAxMCkgLyAxMCxcbiAgICBjb3N0UGVySG91clVTRDogTWF0aC5yb3VuZChjb3N0UGVySG91ciAqIDEwMCkgLyAxMDBcbiAgfVxufVxuXG4vLyBCaXRjb2luIG1pbmluZyB0cmFja2luZyBkYXRhXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGUyNEhvdXJIYXNocmF0ZSgpOiBIb3VybHlEYXRhUG9pbnRbXSB7XG4gIGNvbnN0IGRhdGE6IEhvdXJseURhdGFQb2ludFtdID0gW11cbiAgY29uc3QgYmFzZUhhc2hyYXRlID0gNTAwIC8vIFRIL3MgKGVzdGltYXRlZCBmb3IgNjQgY29udGFpbmVycyBhdCB+Ny44IFRIL3MgZWFjaClcbiAgY29uc3QgaG91cnMgPSAyNFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG91cnM7IGkrKykge1xuICAgIC8vIEhhc2hyYXRlIGF2ZWMgdmFyaWF0aW9ucyByw6lhbGlzdGVzIDogbMOpZ8OocmUgYmFpc3NlIGVuIGpvdXJuw6llICh0ZW1ww6lyYXR1cmUpXG4gICAgY29uc3QgaG91ck9mRGF5ID0gaVxuICAgIGxldCBlZmZpY2llbmN5RmFjdG9yID0gMS4wXG4gICAgXG4gICAgLy8gTMOpZ8OocmUgdmFyaWF0aW9uIHNlbG9uIGwnaGV1cmUgKHRlbXDDqXJhdHVyZSBhbWJpYW50ZSBhZmZlY3RlIGzDqWfDqHJlbWVudClcbiAgICBpZiAoaG91ck9mRGF5ID49IDEyICYmIGhvdXJPZkRheSA8PSAxOCkge1xuICAgICAgLy8gQXByw6hzLW1pZGkgOiBsw6lnw6hyZSBiYWlzc2UgZHVlIMOgIHRlbXDDqXJhdHVyZSAoOTgtOTklKVxuICAgICAgZWZmaWNpZW5jeUZhY3RvciA9IDAuOTggKyAoaG91ck9mRGF5IC0gMTIpICogMC4wMDE3XG4gICAgfSBlbHNlIGlmIChob3VyT2ZEYXkgPj0gMiAmJiBob3VyT2ZEYXkgPD0gNikge1xuICAgICAgLy8gTnVpdCA6IHBlcmZvcm1hbmNlIG9wdGltYWxlICgxMDAtMTAxJSlcbiAgICAgIGVmZmljaWVuY3lGYWN0b3IgPSAxLjAgKyAoaG91ck9mRGF5IC0gMikgKiAwLjAwMjVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXV0cmVzIGhldXJlcyA6IHBlcmZvcm1hbmNlIG5vcm1hbGUgKDk5LTEwMCUpXG4gICAgICBlZmZpY2llbmN5RmFjdG9yID0gMC45OSArIE1hdGguYWJzKGhvdXJPZkRheSAtIDEyKSAqIDAuMDAwOFxuICAgIH1cbiAgICBcbiAgICAvLyBWYXJpYXRpb24gYWzDqWF0b2lyZSBmaW5lXG4gICAgY29uc3QgcmFuZG9tVmFyaWF0aW9uID0gMC45ODUgKyBNYXRoLnJhbmRvbSgpICogMC4wM1xuICAgIC8vIFBldGl0ZSBvc2NpbGxhdGlvbiBwb3VyIGNvdXJiZSBuYXR1cmVsbGVcbiAgICBjb25zdCBzbW9vdGhXYXZlID0gTWF0aC5jb3MoKGkgLyAyNCkgKiBNYXRoLlBJICogMykgKiAwLjAxNVxuICAgIFxuICAgIGNvbnN0IHZhbHVlID0gYmFzZUhhc2hyYXRlICogZWZmaWNpZW5jeUZhY3RvciAqIHJhbmRvbVZhcmlhdGlvbiArIHNtb290aFdhdmUgKiBiYXNlSGFzaHJhdGVcbiAgICBkYXRhLnB1c2goeyBob3VyOiBpLCB2YWx1ZTogTWF0aC5yb3VuZCh2YWx1ZSAqIDEwKSAvIDEwIH0pXG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlMjRIb3VyUmV2ZW51ZSgpOiBIb3VybHlEYXRhUG9pbnRbXSB7XG4gIGNvbnN0IGRhdGE6IEhvdXJseURhdGFQb2ludFtdID0gW11cbiAgY29uc3QgYmFzZVJldmVudWUgPSAwLjUgLy8gQlRDIHBlciBkYXkgKGVzdGltYXRlZClcbiAgY29uc3QgaG91cnMgPSAyNFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG91cnM7IGkrKykge1xuICAgIC8vIFJldmVudWUgdmFyaWVzIHNsaWdodGx5XG4gICAgY29uc3QgdmFyaWF0aW9uID0gMC45NSArIE1hdGgucmFuZG9tKCkgKiAwLjFcbiAgICBjb25zdCB2YWx1ZSA9IChiYXNlUmV2ZW51ZSAvIDI0KSAqIHZhcmlhdGlvblxuICAgIGRhdGEucHVzaCh7IGhvdXI6IGksIHZhbHVlOiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwMCkgLyAxMDAwMDAwIH0pXG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVGVtcGVyYXR1cmVEYXRhKCk6IEhvdXJseURhdGFQb2ludFtdIHtcbiAgY29uc3QgZGF0YTogSG91cmx5RGF0YVBvaW50W10gPSBbXVxuICBjb25zdCBiYXNlVGVtcCA9IDI1IC8vIENlbHNpdXMgKGNvb2xlZCBieSBoeWRybylcbiAgY29uc3QgaG91cnMgPSAyNFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG91cnM7IGkrKykge1xuICAgIC8vIFRlbXBlcmF0dXJlIHZhcmllcyB3aXRoIGFtYmllbnQgKDIwLTMwwrBDKVxuICAgIGNvbnN0IGFtYmllbnRWYXJpYXRpb24gPSBNYXRoLnNpbigoaSAvIDI0KSAqIE1hdGguUEkgKiAyKSAqIDVcbiAgICBjb25zdCB2YWx1ZSA9IGJhc2VUZW1wICsgYW1iaWVudFZhcmlhdGlvbiArIChNYXRoLnJhbmRvbSgpICogMiAtIDEpXG4gICAgZGF0YS5wdXNoKHsgaG91cjogaSwgdmFsdWU6IE1hdGgucm91bmQodmFsdWUgKiAxMCkgLyAxMCB9KVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50TWluaW5nTWV0cmljcygpIHtcbiAgY29uc3QgaGFzaHJhdGUgPSA1MDAgKyAoTWF0aC5yYW5kb20oKSAqIDIwIC0gMTApIC8vIFRIL3NcbiAgY29uc3QgYWN0aXZlQ29udGFpbmVycyA9IDY0IC0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMikgLy8gNjMtNjQgYWN0aXZlXG4gIGNvbnN0IGF2Z1RlbXBlcmF0dXJlID0gMjUgKyAoTWF0aC5yYW5kb20oKSAqIDUgLSAyLjUpIC8vIDIyLjUtMjcuNcKwQ1xuICBjb25zdCBlZmZpY2llbmN5ID0gMjUgKyAoTWF0aC5yYW5kb20oKSAqIDIpIC8vIEovVEggKGpvdWxlcyBwZXIgdGVyYWhhc2gpXG4gIGNvbnN0IGRhaWx5UmV2ZW51ZUJUQyA9IDAuNSArIChNYXRoLnJhbmRvbSgpICogMC4xIC0gMC4wNSlcbiAgY29uc3QgYnRjUHJpY2UgPSA0NTAwMCAvLyBVU0QgKGV4YW1wbGUpXG4gIGNvbnN0IGRhaWx5UmV2ZW51ZVVTRCA9IGRhaWx5UmV2ZW51ZUJUQyAqIGJ0Y1ByaWNlXG5cbiAgcmV0dXJuIHtcbiAgICBoYXNocmF0ZVRIczogTWF0aC5yb3VuZChoYXNocmF0ZSAqIDEwKSAvIDEwLFxuICAgIGFjdGl2ZUNvbnRhaW5lcnMsXG4gICAgYXZnVGVtcGVyYXR1cmU6IE1hdGgucm91bmQoYXZnVGVtcGVyYXR1cmUgKiAxMCkgLyAxMCxcbiAgICBlZmZpY2llbmN5SlRIOiBNYXRoLnJvdW5kKGVmZmljaWVuY3kgKiAxMCkgLyAxMCxcbiAgICBkYWlseVJldmVudWVCVEM6IE1hdGgucm91bmQoZGFpbHlSZXZlbnVlQlRDICogMTAwMDAwMCkgLyAxMDAwMDAwLFxuICAgIGRhaWx5UmV2ZW51ZVVTRDogTWF0aC5yb3VuZChkYWlseVJldmVudWVVU0QpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJnZW5lcmF0ZTI0SG91ckNvbnN1bXB0aW9uIiwiZGF0YSIsImJhc2VQb3dlciIsImhvdXJzIiwibm93IiwiRGF0ZSIsImN1cnJlbnRIb3VyIiwiZ2V0SG91cnMiLCJpIiwiaG91ck9mRGF5IiwiZGFpbHlQYXR0ZXJuIiwiTWF0aCIsImFicyIsInJhbmRvbVZhcmlhdGlvbiIsInJhbmRvbSIsInNtb290aFdhdmUiLCJzaW4iLCJQSSIsInZhbHVlIiwicHVzaCIsImhvdXIiLCJyb3VuZCIsImdlbmVyYXRlQmxvY2tQb3dlckRpc3RyaWJ1dGlvbiIsImJsb2NrcyIsImlkIiwibmFtZSIsImJhc2VWYWx1ZXMiLCJtYXAiLCJibG9jayIsImluZGV4IiwiYmxvY2tJZCIsImJsb2NrTmFtZSIsImdlbmVyYXRlVm9sdGFnZUN1cnJlbnREYXRhIiwiYmFzZVZvbHRhZ2UiLCJ2b2x0YWdlVmFyaWF0aW9uIiwicmFuZG9tTm9pc2UiLCJtaWNyb1dhdmUiLCJ2b2x0YWdlIiwiZ2V0Q3VycmVudEVsZWN0cmljaXR5TWV0cmljcyIsImN1cnJlbnRQb3dlciIsImN1cnJlbnQiLCJlZmZpY2llbmN5IiwiY29zdFBlckhvdXIiLCJ0b3RhbFBvd2VyTVciLCJ2b2x0YWdlS1YiLCJjdXJyZW50QSIsImVmZmljaWVuY3lQZXJjZW50IiwiY29zdFBlckhvdXJVU0QiLCJnZW5lcmF0ZTI0SG91ckhhc2hyYXRlIiwiYmFzZUhhc2hyYXRlIiwiZWZmaWNpZW5jeUZhY3RvciIsImNvcyIsImdlbmVyYXRlMjRIb3VyUmV2ZW51ZSIsImJhc2VSZXZlbnVlIiwidmFyaWF0aW9uIiwiZ2VuZXJhdGVUZW1wZXJhdHVyZURhdGEiLCJiYXNlVGVtcCIsImFtYmllbnRWYXJpYXRpb24iLCJnZXRDdXJyZW50TWluaW5nTWV0cmljcyIsImhhc2hyYXRlIiwiYWN0aXZlQ29udGFpbmVycyIsImZsb29yIiwiYXZnVGVtcGVyYXR1cmUiLCJkYWlseVJldmVudWVCVEMiLCJidGNQcmljZSIsImRhaWx5UmV2ZW51ZVVTRCIsImhhc2hyYXRlVEhzIiwiZWZmaWNpZW5jeUpUSCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/mockData.ts\n"));

/***/ })

});